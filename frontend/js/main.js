 // å…¨å±€å˜é‡
 // AIé¼“åŠ±è¯­ç›¸å…³å…¨å±€å˜é‡
let aiGeneratedResults = [];
let aiPromptHistory = JSON.parse(localStorage.getItem('aiPromptHistory') || '[]');
 let currentPage = 'home';
 let isTimerRunning = false;
 let isPaused = false;
 let currentTime = 25 * 60;
 let selectedMinutes = 25;
 let timerInterval = null;
 let currentMode = 'pomodoro';
 let currentStatus = { name: '', icon: 'âšª' };
 let currentMusicMode = 0;
 // éŸ³é¢‘ç®¡ç†
 let currentBackgroundMusic = null;
 let completionAudio = null;
 let isMusicEnabled = true;
 let musicPausedTime = 0; 
let musicType = 'mute'; 

// éŸ³é¢‘æ–‡ä»¶URL
const audioFiles = {
music: 'https://raw.githubusercontent.com/dengxi-cpu/Pomodoro/main/music.mp3',
rain: 'https://raw.githubusercontent.com/dengxi-cpu/Pomodoro/main/storm.mp3',
completion: 'https://raw.githubusercontent.com/dengxi-cpu/Pomodoro/main/commission_finished.MP3'
};
 let isStatusSelected = false;
 // è‡ªå®šä¹‰çŠ¶æ€å­˜å‚¨ï¼ˆæ–°å¢ï¼‰
let customStatuses = {};  // å­˜å‚¨è‡ªå®šä¹‰çŠ¶æ€çš„å›¾æ ‡ç­‰ä¿¡æ¯
 let currentTask = { name: 'å¤ä¹ è‹±è¯­å•è¯', status: 'è¿›è¡Œä¸­', color: 'blue' };
 const musicIcons = ['ğŸ”‡', 'ğŸµ', 'ğŸŒ§ï¸'];
 
 // 4.1 å…¨å±€å˜é‡ï¼ˆ
 let statusGifts = {
'å­¦ä¹ ': [
 'ğŸ† å­¦éœ¸ä¸“å±å¥–æ¯ï¼çŸ¥è¯†çš„åŠ›é‡è®©ä½ é—ªé—ªå‘å…‰ï¼',
 'ğŸ“– ä½ å¿µå¨è¿‡çš„ç»ç‰ˆä¹¦ï¼ˆTaåœ¨å¤ç±ä¹¦åº—è¹²äº†2å°æ—¶ï¼‰',
 'â­ å­¦ä¹ ä¹‹æ˜Ÿå¾½ç« ï¼ä½ å°±æ˜¯æœ€äº®çš„é‚£é¢—æ˜Ÿï¼',
 'ğŸ–‹ï¸ å®šåˆ¶é’¢ç¬”ï¼ˆç¬”å¤¹åˆ»ç€ä½ åå­—ç¼©å†™ï¼Œå¢¨è‰²æ˜¯ä½ æœ€çˆ±çš„ç°ç´«ï¼‰',
 'ğŸ“ å†™æ»¡å¿ƒå¾—çš„ç¬”è®°ï¼ˆåœ¨é‡ç‚¹é¡µå¤¹ç€é“¶æä¹¦ç­¾ï¼š"æ­¤å¤„ä½ ä¼šå–œæ¬¢"ï¼‰',
 'ğŸ’ çŸ¥è¯†å®çŸ³ï¼æ¯”é’»çŸ³æ›´çè´µçš„æ˜¯ä½ çš„åŠªåŠ›ï¼'
 
],
'å·¥ä½œ': [
 'ğŸ± è§£å‹å°ç‰©ï¼ˆä¼šæ‘‡å¤´çš„çŒ«å’ªæ‘†ä»¶â€”â€”"æ”¾ä½ ç”µè„‘æ—ï¼Œæ›¿æˆ‘ç›‘ç£ä½ ä¼‘æ¯"ï¼‰',
 'ğŸš€ æ•ˆç‡ç«ç®­ï¼å·¥ä½œçŠ¶æ€æ»¡åˆ†ï¼',
 'âš¡ ç”Ÿäº§åŠ›é—ªç”µï¼ä»Šå¤©çš„ä½ è¶…çº§ç»™åŠ›ï¼',
 'âœ¨ æ˜Ÿç©ºæŠ•å½±ç¯ï¼ˆåŠ ç­å¤œæŒ‘çš„ï¼š"ä»¥åæˆ‘æ™šå½’ï¼Œè®©å®ƒé™ªä½ å…¥ç¡"ï¼‰',
 'ğŸ§ ä½ æœ€å–œæ¬¢çš„ç”œå“ï¼ˆç”¨æ‰‹å¸•ä»”ç»†åŒ…ç€ï¼š"ä½ è¯´è¿‡è¿™æ¬¾æœ€å¥½åƒ"ï¼‰'
],
'å†’é™©': [
 'ğŸ—ºï¸ å†’é™©å®¶åœ°å›¾ï¼æ¯ä¸€æ­¥éƒ½æ˜¯æ–°çš„å‘ç°ï¼',
 'ğŸŒŒ å±±é¡¶æ‹çš„æ˜Ÿç©ºç…§ï¼ˆèƒŒåå†™ç€ï¼šæˆ‘çš„å®‡å®™ä¸­å¿ƒæ˜¯ä½ ï¼‰',
 'ğŸ´â€â˜ ï¸ æ¢é™©æ——å¸œï¼æœªçŸ¥çš„ä¸–ç•Œåœ¨ç­‰ç€ä½ ï¼',
 'ğŸ’§ æ£®æ—éœ²æ°´ï¼ˆæ°´æ™¶ç“¶è£…ç€ï¼‰',
 'ğŸ’ ä¼šå‘å…‰çš„çŸ¿çŸ³ï¼ˆåµŒæˆé¡¹é“¾ï¼‰'
],
'é€›è¡—': [
 'ğŸ§¦ é”™ç‰ˆè¢œå­ï¼ˆå·¦è“çŒ«å³æ©˜çŒ«ï¼‰',
 'â˜• æ‰‹ä½œé™¶æ³¥æ¯ï¼ˆæ¯æŸ„ææˆæ­ªå¿ƒå½¢ï¼‰',
 'ğŸ‘  æ—¶å°šå¥³ç‹é«˜è·Ÿé‹ï¼èµ°è·¯éƒ½å¸¦é£ï¼',
 'ğŸ’„ ç¾å¦†å¤§å¸ˆå¥—è£…ï¼ä½ å°±æ˜¯æœ€ç¾çš„é£æ™¯ï¼',
 'ğŸ’ ä½ å–œæ¬¢çš„é¦™æ°´ï¼ˆ"ç°åœ¨é£ç»è¿‡ä½ ï¼Œéƒ½æ˜¯ä½ çš„å‘³é“"ï¼‰'
],
'ç©æ¸¸æˆ': [
 'ğŸ® æ¸¸æˆå¤§ç¥æ‰‹æŸ„ï¼æŠ€æœ¯æµå°±æ˜¯ä½ ï¼',
 'ğŸ† ç”µç«å† å†›å¥–æ¯ï¼èœé¸Ÿä»€ä¹ˆçš„ä¸å­˜åœ¨ï¼',
 'ğŸ’ æ¸¸æˆå¸ç†”çš„æˆ’æŒ‡ï¼ˆå†…ä¾§åˆ»ä½ çš„åå­—ï¼‰',
 'ğŸ¯ ç™¾å‘ç™¾ä¸­å‹‹ç« ï¼ç²¾å‡†åº¦MAXï¼',
 'ğŸ”¥ è¿èƒœç«ç„°ï¼ä»Šå¤©çŠ¶æ€çˆ†è¡¨ï¼'
],
'å‘å‘†': [
 'â˜ï¸ æ€è€ƒäº‘æœµï¼æ”¾ç©ºä¹Ÿæ˜¯ä¸€ç§æ™ºæ…§ï¼',
 'ğŸ· ä¾¿åˆ©åº—æ”¶æ®èƒŒé¢æ¶‚é¸¦ï¼ˆç”»ä½ ç¡è„¸ï¼š"ç›‘æ§æ‹åˆ°æŸåªå°çŒªå·æ‡’è¯æ®"ï¼‰',
 'â˜ï¸ äº‘æœµå½¢çŠ¶çš„çŸ³å¤´ï¼ˆæ”¾ä½ æ‰‹å¿ƒï¼š"å®ƒé£˜ç´¯äº†ï¼Œæ¥ä½ è¿™é‡Œé™è½"ï¼‰',
 'ğŸ¦‹ é“¶æå¶æ‹¼æˆçš„è´è¶ï¼ˆå¤¹åœ¨è¯—é›†ç¬¬14é¡µï¼š"ä½ ç”Ÿæ—¥é‚£å¤©çš„é£é€æ¥çš„"ï¼‰',
 'ğŸ’­ åˆ›æ„æ³¡æ³¡ï¼ä¸‹ä¸€ä¸ªå¥½ç‚¹å­å°±è¦å†’å‡ºæ¥äº†ï¼'
],
'ç¡è§‰': [
 'ğŸ˜´ å¥½æ¢¦æˆçœŸæ•å¤´ï¼ç”œç¾æ¢¦å¢ƒç­‰ç€ä½ ï¼',
 'ğŸŒ™ æ•å¤´æš–æ„ï¼ˆæŠŠå‘çƒ­çœ¼ç½©å¡ç»™ä½ ï¼š"å€Ÿä½ å……ç”µ5åˆ†é’Ÿ"ï¼‰',
 'â­ æ˜Ÿæ˜Ÿå®‰çœ æ›²ï¼è®©æ˜Ÿå…‰é™ªä½ å…¥ç¡ï¼',
 'ğŸ›ï¸ äº‘æœµåºŠé“ºï¼åƒèººåœ¨äº‘ç«¯ä¸€æ ·èˆ’é€‚ï¼',
 'ğŸ’­ å‹çš±çš„æ¢¦å¢ƒï¼ˆä¾¿ç­¾å†™ç€ï¼š"æ¢¦è§æˆ‘æŠ¢ä½ å†°æ·‡æ·‹ï¼Œèµ”ä½ å¼ å…‘æ¢åˆ¸"ï¼‰'
],
'ä¼‘æ¯': [
 'ğŸŒ¿ æ”¾æ¾å¶å­ï¼è®©ç–²æƒ«éšé£é£˜æ•£ï¼',
 'ğŸƒ æ¸…æ–°è–„è·ï¼ç¬é—´æ¢å¤æ´»åŠ›ï¼',
 'ğŸŒº èˆ’ç¼“èŠ±æœµï¼èº«å¿ƒéƒ½å¾—åˆ°äº†æ²»æ„ˆï¼',
 'ğŸŒ» è€å¥¶å¥¶å–çš„ç»’çº¿èŠ±ï¼ˆæ°¸ä¸å‡‹è°¢çš„å‘æ—¥è‘µï¼š"å¥¹è¯´è¦é€ç»™çˆ±ç¬‘çš„å°å§‘å¨˜"ï¼‰',
 'ğŸ æµæµªçŒ«é€çš„è°¢ç¤¼ï¼ˆæ¾æœæ¶‚æˆé‡‘è‰²ï¼š"ç”¨å°é±¼å¹²æ¢çš„"ï¼‰'
]
};

let currentEditingStatus = '';
let currentEditingStatusIcon = '';
// 4.2 çŠ¶æ€ç¤¼ç‰©ç¼–è¾‘ç›¸å…³å‡½æ•°
function editStatusGift(statusName, statusIcon) {
currentEditingStatus = statusName;
currentEditingStatusIcon = statusIcon;

const modal = document.getElementById('statusGiftEditorModal');
const title = document.getElementById('statusGiftEditorTitle');
const icon = document.getElementById('statusGiftEditorIcon');
const textarea = document.getElementById('statusGiftEditorTextarea');

title.textContent = `ç¼–è¾‘${statusName}ç¤¼ç‰©`;
icon.textContent = statusIcon;

// åŠ è½½å½“å‰çŠ¶æ€çš„ç¤¼ç‰©å†…å®¹
const currentGifts = statusGifts[statusName] || [];
textarea.value = currentGifts.join('\n');

modal.classList.add('show');
}

function closeStatusGiftEditor() {
document.getElementById('statusGiftEditorModal').classList.remove('show');
}

function saveStatusGifts() {
const textarea = document.getElementById('statusGiftEditorTextarea');
const gifts = textarea.value.trim().split('\n').filter(line => line.trim());

// ä¿å­˜ç¤¼ç‰©å†…å®¹
statusGifts[currentEditingStatus] = gifts;

// ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
saveStatusGiftsToStorage();

// æ›´æ–°é¢„è§ˆæ˜¾ç¤º
updateStatusGiftPreview(currentEditingStatus);

closeStatusGiftEditor();
alert('ç¤¼ç‰©å·²ä¿å­˜ï¼');
}

function updateStatusGiftPreview(statusName) {
const card = document.querySelector(`[data-status="${statusName}"]`);
if (card) {
 const preview = card.querySelector('.status-gift-preview');
 const gifts = statusGifts[statusName] || [];
 if (gifts.length > 0) {
     // æ˜¾ç¤ºå‰ä¸¤ä¸ªç¤¼ç‰©ä½œä¸ºé¢„è§ˆ
     const previewText = gifts.slice(0, 2).join('ï¼›');
     preview.textContent = previewText.length > 40 ? previewText.substring(0, 40) + '...' : previewText;
 } else {
     preview.textContent = 'ç‚¹å‡»ç¼–è¾‘ç¤¼ç‰©å†…å®¹';
 }
}
}

function createCustomStatusGift() {
// å¼¹å‡ºè¾“å…¥æ¡†è®©ç”¨æˆ·è¾“å…¥çŠ¶æ€åç§°
const statusName = prompt('è¯·è¾“å…¥è‡ªå®šä¹‰çŠ¶æ€åç§°ï¼ˆå»ºè®®2-4ä¸ªå­—ç¬¦ï¼‰ï¼š');

if (!statusName || !statusName.trim()) {
 return;
}

const trimmedName = statusName.trim();
if (trimmedName.length > 6) {
 alert('çŠ¶æ€åç§°ä¸èƒ½è¶…è¿‡6ä¸ªå­—ç¬¦');
 return;
}

// æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
if (statusGifts[trimmedName]) {
 alert('è¯¥çŠ¶æ€å·²å­˜åœ¨');
 return;
}

// è®©ç”¨æˆ·é€‰æ‹©å›¾æ ‡
const statusIcon = prompt('è¯·è¾“å…¥çŠ¶æ€å›¾æ ‡ï¼ˆemojiè¡¨æƒ…ï¼‰ï¼š', 'âœ¨');

if (!statusIcon || !statusIcon.trim()) {
 return;
}

const trimmedIcon = statusIcon.trim();

// åˆå§‹åŒ–çŠ¶æ€ç¤¼ç‰©
statusGifts[trimmedName] = ['åœ¨è¿™é‡Œè¾“å…¥ç¤¼ç‰©å†…å®¹ï¼Œæ¯è¡Œä¸€ä¸ª...'];

// ä¿å­˜è‡ªå®šä¹‰çŠ¶æ€ä¿¡æ¯ï¼ˆæ–°å¢ï¼‰
customStatuses[trimmedName] = {
 icon: trimmedIcon,
 name: trimmedName,
 isCustom: true
};

// ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
saveStatusGiftsToStorage();
saveCustomStatusesToStorage(); // æ–°å¢

// æ·»åŠ å¡ç‰‡åˆ°é¡µé¢
addCustomStatusCard(trimmedName, trimmedIcon);

// åŒæ­¥åˆ°ä¸“æ³¨é¡µé¢ï¼ˆæ–°å¢ï¼‰
syncCustomStatusToFocusPage(trimmedName, trimmedIcon);

// è‡ªåŠ¨æ‰“å¼€ç¼–è¾‘å™¨
setTimeout(() => {
 editStatusGift(trimmedName, trimmedIcon);
}, 100);
}


function addCustomStatusCard(statusName, statusIcon) {
const grid = document.getElementById('statusGiftGrid');
const customButton = grid.querySelector('.custom-status-card');

const newCard = document.createElement('div');
newCard.className = 'status-gift-card';
newCard.setAttribute('data-status', statusName);

newCard.innerHTML = `
 <div class="status-gift-header">
     <span class="status-gift-icon">${statusIcon}</span>
     <span class="status-gift-name">${statusName}</span>
 </div>
 <div class="status-gift-preview">ç‚¹å‡»ç¼–è¾‘ç¤¼ç‰©å†…å®¹</div>
 <div class="status-gift-edit-indicator">âœï¸</div>
 <button class="custom-status-delete" title="åˆ é™¤æ­¤è‡ªå®šä¹‰çŠ¶æ€">
     <svg class="w-3 h-3 text-red-500" fill="currentColor" viewBox="0 0 24 24">
         <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
     </svg>
 </button>
`;

// æ’å…¥åˆ°è‡ªå®šä¹‰æŒ‰é’®ä¹‹å‰
if (customButton) {
 grid.insertBefore(newCard, customButton);
}

// åŒæ­¥åˆ°ä¸“æ³¨é¡µçŠ¶æ€é€‰æ‹©å™¨
syncCustomStatusToFocusPage(statusName, statusIcon);
}

function deleteCustomStatusGift(statusName) {
// æ£€æŸ¥æ˜¯å¦æ˜¯é¢„è®¾çŠ¶æ€
const presetStatuses = ['å­¦ä¹ ', 'å·¥ä½œ', 'å†’é™©', 'é€›è¡—', 'ç©æ¸¸æˆ', 'å‘å‘†', 'ç¡è§‰', 'ä¼‘æ¯'];
if (presetStatuses.includes(statusName)) {
 alert('é¢„è®¾çŠ¶æ€ä¸èƒ½åˆ é™¤ï¼Œåªèƒ½ç¼–è¾‘');
 return;
}

if (confirm(`ç¡®å®šè¦åˆ é™¤"${statusName}"çŠ¶æ€å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`)) {
 // ä»å­˜å‚¨ä¸­åˆ é™¤
 delete statusGifts[statusName];
 delete customStatuses[statusName];
 
 // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
 saveStatusGiftsToStorage();
 saveCustomStatusesToStorage();
 
 // ä»é¡µé¢ä¸­ç§»é™¤å¡ç‰‡
 const card = document.querySelector(`[data-status="${statusName}"]`);
 if (card) {
     card.remove();
 }
 
 // ä»ä¸“æ³¨é¡µç§»é™¤å¯¹åº”çš„çŠ¶æ€é€‰é¡¹
 removeCustomStatusFromFocusPage(statusName);
 
 // æç¤ºåˆ é™¤æˆåŠŸ
 console.log(`å·²åˆ é™¤è‡ªå®šä¹‰çŠ¶æ€: ${statusName}`);
}
}



function saveStatusGiftsToStorage() {
localStorage.setItem('statusGifts', JSON.stringify(statusGifts));
}
// ä¿å­˜è‡ªå®šä¹‰çŠ¶æ€åˆ°æœ¬åœ°å­˜å‚¨ï¼ˆæ–°å¢ï¼‰
function saveCustomStatusesToStorage() {
localStorage.setItem('customStatuses', JSON.stringify(customStatuses));
}

// ä»æœ¬åœ°å­˜å‚¨åŠ è½½è‡ªå®šä¹‰çŠ¶æ€ï¼ˆæ–°å¢ï¼‰
function loadCustomStatusesFromStorage() {
const saved = localStorage.getItem('customStatuses');
if (saved) {
 try {
     customStatuses = JSON.parse(saved);
 } catch (e) {
     console.log('Failed to parse custom statuses');
     customStatuses = {};
 }
}
}

// åŒæ­¥è‡ªå®šä¹‰çŠ¶æ€åˆ°ä¸“æ³¨é¡µé¢ï¼ˆæ–°å¢ï¼‰
function syncCustomStatusToFocusPage(statusName, statusIcon) {
const statusGrid = document.querySelector('#statusSelector .status-grid');
if (!statusGrid) return;

// æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
const existingOption = statusGrid.querySelector(`[data-custom-status="${statusName}"]`);
if (existingOption) return;

// åˆ›å»ºæ–°çš„çŠ¶æ€é€‰é¡¹
const statusOption = document.createElement('div');
statusOption.className = 'status-option';
statusOption.setAttribute('data-custom-status', statusName);
statusOption.onclick = () => selectStatus(statusName, statusIcon);

statusOption.innerHTML = `
 <span class="status-icon">${statusIcon}</span>
 <span class="status-text">${statusName}</span>
`;

// æ’å…¥åˆ°è‡ªå®šä¹‰é€‰é¡¹ä¹‹å‰
const customStatusOption = statusGrid.querySelector('[onclick="showCustomStatusInput()"]');
if (customStatusOption) {
 statusGrid.insertBefore(statusOption, customStatusOption);
} else {
 statusGrid.appendChild(statusOption);
}
}

// ä»ä¸“æ³¨é¡µé¢ç§»é™¤è‡ªå®šä¹‰çŠ¶æ€ï¼ˆæ–°å¢ï¼‰
function removeCustomStatusFromFocusPage(statusName) {
const statusOption = document.querySelector(`[data-custom-status="${statusName}"]`);
if (statusOption) {
 statusOption.remove();
}
}

// åˆå§‹åŒ–ä¸“æ³¨é¡µé¢çš„è‡ªå®šä¹‰çŠ¶æ€é€‰é¡¹ï¼ˆæ–°å¢ï¼‰
function initCustomStatusInFocusPage() {
Object.keys(customStatuses).forEach(statusName => {
 const statusInfo = customStatuses[statusName];
 syncCustomStatusToFocusPage(statusName, statusInfo.icon);
});
}



function loadStatusGiftsFromStorage() {
const saved = localStorage.getItem('statusGifts');
if (saved) {
 try {
     const loaded = JSON.parse(saved);
     // åˆå¹¶é»˜è®¤çŠ¶æ€ç¤¼ç‰©å’Œè‡ªå®šä¹‰çŠ¶æ€ç¤¼ç‰©
     statusGifts = { ...statusGifts, ...loaded };
 } catch (e) {
     console.log('Failed to parse status gifts');
 }
}
}

function initializeStatusGiftPreviews() {
// ç¡®ä¿DOMå‡†å¤‡å¥½å†æ‰§è¡Œ
const statusGiftGrid = document.getElementById('statusGiftGrid');
if (!statusGiftGrid) {
 setTimeout(initializeStatusGiftPreviews, 100);
 return;
}

// åˆå§‹åŒ–æ‰€æœ‰çŠ¶æ€ç¤¼ç‰©å¡ç‰‡çš„é¢„è§ˆ
Object.keys(statusGifts).forEach(statusName => {
 updateStatusGiftPreview(statusName);
});

// åŠ è½½è‡ªå®šä¹‰çŠ¶æ€å¡ç‰‡
loadCustomStatusCards();

// ç»‘å®šäº‹ä»¶ï¼ˆå»¶è¿Ÿç¡®ä¿DOMå®Œå…¨æ¸²æŸ“ï¼‰
setTimeout(() => {
 bindStatusGiftCardEvents();
}, 50);

// å¦‚æœå½“å‰åœ¨ä¸“æ³¨é¡µé¢ï¼ŒåŒæ­¥è‡ªå®šä¹‰çŠ¶æ€
if (currentPage === 'focus') {
 initCustomStatusInFocusPage();
}
}

function bindStatusGiftCardEvents() {
// æ£€æŸ¥DOMæ˜¯å¦å‡†å¤‡å¥½
const statusGiftGrid = document.getElementById('statusGiftGrid');
if (!statusGiftGrid) {
 console.log('çŠ¶æ€ç¤¼ç‰©ç½‘æ ¼æœªæ‰¾åˆ°ï¼Œå»¶è¿Ÿç»‘å®š');
 setTimeout(bindStatusGiftCardEvents, 100);
 return;
}

// ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨ï¼ˆé˜²æ­¢é‡å¤ç»‘å®šï¼‰
statusGiftGrid.removeEventListener('click', handleStatusGiftCardClick);

// æ·»åŠ æ–°çš„äº‹ä»¶ç›‘å¬å™¨ï¼ˆäº‹ä»¶å§”æ‰˜ï¼‰
statusGiftGrid.addEventListener('click', handleStatusGiftCardClick);

console.log('çŠ¶æ€ç¤¼ç‰©å¡ç‰‡äº‹ä»¶å·²ç»‘å®š');
}

// æ–°å¢ï¼šç»Ÿä¸€çš„äº‹ä»¶å¤„ç†å‡½æ•°
function handleStatusGiftCardClick(event) {
const clickedElement = event.target;
const card = clickedElement.closest('.status-gift-card');

if (!card) return;

// é˜»æ­¢äº‹ä»¶å†’æ³¡
event.stopPropagation();

// å¦‚æœç‚¹å‡»çš„æ˜¯åˆ é™¤æŒ‰é’®
if (clickedElement.closest('.custom-status-delete')) {
 const statusName = card.getAttribute('data-status');
 deleteCustomStatusGift(statusName);
 return;
}

// å¦‚æœç‚¹å‡»çš„æ˜¯è‡ªå®šä¹‰çŠ¶æ€åˆ›å»ºæŒ‰é’®
if (card.classList.contains('custom-status-card')) {
 createCustomStatusGift();
 return;
}

// å…¶ä»–æƒ…å†µï¼šç¼–è¾‘ç¤¼ç‰©
const statusName = card.getAttribute('data-status');
const iconElement = card.querySelector('.status-gift-icon');
const statusIcon = iconElement ? iconElement.textContent : 'âœ¨';

editStatusGift(statusName, statusIcon);
}

function loadCustomStatusCards() {
const presetStatuses = ['å­¦ä¹ ', 'å·¥ä½œ', 'å†’é™©', 'é€›è¡—', 'ç©æ¸¸æˆ', 'å‘å‘†', 'ç¡è§‰', 'ä¼‘æ¯'];
const customStatuses = Object.keys(statusGifts).filter(status => !presetStatuses.includes(status));

customStatuses.forEach(statusName => {
 // ä¸ºè‡ªå®šä¹‰çŠ¶æ€åˆ›å»ºå›¾æ ‡ï¼ˆå¯ä»¥ä»ä¸“æ³¨é¡µçš„çŠ¶æ€é€‰æ‹©å™¨ä¸­è·å–ï¼Œæˆ–ä½¿ç”¨é»˜è®¤å›¾æ ‡ï¼‰
 const statusIcon = 'âœ¨'; // é»˜è®¤å›¾æ ‡ï¼Œå¯ä»¥è€ƒè™‘ä¿å­˜å›¾æ ‡ä¿¡æ¯
 addCustomStatusCard(statusName, statusIcon);
 updateStatusGiftPreview(statusName);
});
}
// åŒæ­¥è‡ªå®šä¹‰çŠ¶æ€åˆ°ä¸“æ³¨é¡µ
function syncCustomStatusToFocusPage(statusName, statusIcon) {
const statusGrid = document.querySelector('#statusSelector .status-grid');
if (!statusGrid) return;

// æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
const existingOption = statusGrid.querySelector(`[data-custom-status="${statusName}"]`);
if (existingOption) return;

// åˆ›å»ºæ–°çš„çŠ¶æ€é€‰é¡¹
const statusOption = document.createElement('div');
statusOption.className = 'status-option';
statusOption.setAttribute('data-custom-status', statusName);
statusOption.onclick = () => selectStatus(statusName, statusIcon);

statusOption.innerHTML = `
 <span class="status-icon">${statusIcon}</span>
 <span class="status-text">${statusName}</span>
`;

// æ’å…¥åˆ°è‡ªå®šä¹‰é€‰é¡¹ä¹‹å‰
const customStatusOption = statusGrid.querySelector('[onclick="showCustomStatusInput()"]');
if (customStatusOption) {
 statusGrid.insertBefore(statusOption, customStatusOption);
}
}

// ä»ä¸“æ³¨é¡µç§»é™¤è‡ªå®šä¹‰çŠ¶æ€
function removeCustomStatusFromFocusPage(statusName) {
const statusOption = document.querySelector(`[data-custom-status="${statusName}"]`);
if (statusOption) {
 statusOption.remove();
}
}

// åˆå§‹åŒ–ä¸“æ³¨é¡µçš„è‡ªå®šä¹‰çŠ¶æ€é€‰é¡¹
function initCustomStatusInFocusPage() {
const presetStatuses = ['å­¦ä¹ ', 'å·¥ä½œ', 'å†’é™©', 'é€›è¡—', 'ç©æ¸¸æˆ', 'å‘å‘†', 'ç¡è§‰', 'ä¼‘æ¯'];
const customStatuses = Object.keys(statusGifts).filter(status => !presetStatuses.includes(status));

customStatuses.forEach(statusName => {
 // å°è¯•ä»æœ¬åœ°å­˜å‚¨è·å–å›¾æ ‡ï¼Œæˆ–ä½¿ç”¨é»˜è®¤å›¾æ ‡
 const statusIcon = getCustomStatusIcon(statusName) || 'âœ¨';
 syncCustomStatusToFocusPage(statusName, statusIcon);
});
}

// è·å–è‡ªå®šä¹‰çŠ¶æ€çš„å›¾æ ‡ï¼ˆå¯ä»¥æ‰©å±•ä¿å­˜å›¾æ ‡åŠŸèƒ½ï¼‰
function getCustomStatusIcon(statusName) {
// å¯ä»¥ä»localStorageè·å–ä¿å­˜çš„å›¾æ ‡ä¿¡æ¯
const customStatusIcons = JSON.parse(localStorage.getItem('customStatusIcons') || '{}');
return customStatusIcons[statusName] || 'âœ¨';
}

// ä¿å­˜è‡ªå®šä¹‰çŠ¶æ€å›¾æ ‡
function saveCustomStatusIcon(statusName, statusIcon) {
const customStatusIcons = JSON.parse(localStorage.getItem('customStatusIcons') || '{}');
customStatusIcons[statusName] = statusIcon;
localStorage.setItem('customStatusIcons', JSON.stringify(customStatusIcons));
}


 // OCäº¤äº’ç›¸å…³å˜é‡
 let clickCount = 0;
 let clickTimer = null;
 let recoveryTimer = null;
 let ignoreTimer = null;
 let canInteract = true;
 let isIgnoring = false;
 let focusStartOCIndex = 0;
 
 // OCè¯­ç³»ç»Ÿç›¸å…³å˜é‡
 let encourageInterval = null;
 let currentMessageType = 'initial';
 
 // è‡ªå®šä¹‰é£æ ¼å­˜å‚¨ - ä¼˜åŒ–ç»“æ„ï¼Œæ”¯æŒé£æ ¼å…ƒæ•°æ®
 let customStyles = {
     encourage: {},
     remind: {},
     metadata: {} // å­˜å‚¨è‡ªå®šä¹‰é£æ ¼çš„å…ƒæ•°æ®ï¼ˆæ ‡é¢˜ã€æè¿°ç­‰ï¼‰
 };
 
 // è¯­æ–™åº“
 const ocMessageLibrary = {
     // é¼“åŠ±è¯­åº“
     encourage: {
         gentle: [
             "{title}ï¼Œä½ çš„ä¾§è„¸çœŸæ˜¯ç™¾çœ‹ä¸åŒå‘¢",
                  "{title}å°±è¿™æ ·æ²‰æµ¸åœ¨è‡ªå·±çš„ä¸–ç•Œé‡Œå§ï¼Œæˆ‘ä¼šå¥½å¥½å®ˆæŠ¤ä½ çš„ã€‚",
                  "{title}ï¼Œæˆ‘çš„ç›®å…‰ä¼šä¸€ç›´è¿½éšç€ä½ å“¦",
                 "ä¹–{title}ï¼Œé›†ä¸­ç²¾ç¥ï¼Œæˆ‘åœ¨è¿™å„¿å‘¢ã€‚",
              "{title}ï¼Œæ„Ÿè§‰æ—¶é—´éƒ½å˜æ…¢äº†ï¼Œç©ºæ°”é‡Œå…¨æ˜¯ä½ çš„å‘³é“~",
              "{title}å¶å°”çš±çœ‰å¤´çš„æ ·å­ï¼Œä¹Ÿå¥½å¯çˆ±å‘€ï¼",
               "{title}ï¼Œå°±æŒ‰ä½ çš„èŠ‚å¥æ¥ï¼Œä¸ç”¨æ…Œ",
                 "çœ‹ç€{title}åŠªåŠ›çš„æ ·å­ï¼ŒçœŸçš„å¥½å®‰å¿ƒã€‚",
                 "{title}æ˜¯ä¸æ˜¯æœ‰ç‚¹ç´¯äº†ï¼ŸåšæŒä½ï¼Œæˆ‘åœ¨å¿ƒé‡Œä¸ºä½ åŠ æ²¹",
                 "{title}çš„åŠªåŠ›ï¼Œæˆ‘éƒ½æœ‰å¥½å¥½çœ‹åœ¨çœ¼é‡Œå‘¢ï¼",
                 "å¥½æƒ³æ‘¸æ‘¸{title}çš„å¤´ï¼Œåˆæ€•æ‰“æ‰°ä½ ï¼Œåªèƒ½å¿ä½å•¦",
                 "å—¯~æˆ‘çš„å®è´çœŸè®¤çœŸå‘¢...è¿™ä¸ªä¾§è„¸ï¼Œä¸“æ³¨çš„æ ·å­ï¼Œå¤ªè®©äººå¿ƒåŠ¨å•¦ï¼",
                 "æ—¶é—´åœ¨èµ°ï¼Œä½†æˆ‘çš„ç›®å…‰åªä¸ºä½ åœç•™ã€‚{title}åšå¾—å¾ˆå¥½ï¼Œæ¯”ä»»ä½•äººéƒ½æ£’ï¼",
                 "ä»Šå¤©ä¹Ÿå¥½å–œæ¬¢{title}ï¼Œä½ åŠªåŠ›çš„æ ·å­çœŸå¥½çœ‹",
                 "{title}ï¼Œç¯å…‰å¤Ÿäº®å—ï¼Ÿå§¿åŠ¿èˆ’æœå—ï¼Ÿè¦å¥½å¥½ç…§é¡¾è‡ªå·±å‘€"
         ],
         tsundere: [
             "å“¼ï¼Œé©¬é©¬è™è™è¿˜ç®—è®¤çœŸã€‚â€¦ ç»§ç»­ä¿æŒï¼Œåˆ«è®©æˆ‘å¤±æœ›ã€‚",
             "åˆ«ä¸œå¼ è¥¿æœ›ï¼â€¦ ä¸“å¿ƒç‚¹ï¼â€¦ å’³ï¼Œæˆ‘æ˜¯è¯´â€¦ ä½ è®¤çœŸèµ·æ¥çš„æ ·å­â€¦ è¿˜ã€è¿˜è¡Œå§ã€‚",
             "é‡åˆ°éš¾é¢˜äº†ï¼Ÿâ€¦ å“¼ï¼Œå°±çŸ¥é“ä½ æä¸å®šã€‚â€¦ è¿‡æ¥ç‚¹ï¼Œæˆ‘â€¦ æˆ‘å‹‰å¼ºæŒ‡ç‚¹ä½ ä¸€ä¸‹ã€‚",
             "å–‚ï¼Œå¤´å¤ªä½äº†ï¼â€¦ æ³¨æ„å§¿åŠ¿ï¼â€¦ æˆ‘æ˜¯ä¸ºä½ å¥½ï¼Œæ‰ä¸æ˜¯å…³å¿ƒä½ ï¼",
             "å…¶å®ï¼Œä½ æ¯”æˆ‘æƒ³è±¡ä¸­åšæŒå¾—ä¹…ä¸€ç‚¹ã€‚â€¦ ä¹Ÿå°±ä¸€ç‚¹ï¼åˆ«å¾—æ„ï¼",
             "å“¼ï¼Œè¿˜ç®—æœ‰ç‚¹æ¯…åŠ›ã€‚â€¦ ç»§ç»­ä¿æŒï¼Œç»ˆç‚¹å°±åœ¨å‰é¢äº†ï¼Œåˆ«æ¾æ‡ˆï¼",
             "ä¹Ÿå°±åªæœ‰è®¤çœŸçš„æ—¶å€™ï¼Œçœ‹èµ·æ¥è¿˜ç®—â€¦â€¦é¡ºçœ¼ã€‚",
             "åˆ«ä¸œå¼ è¥¿æœ›çš„ï¼Œæˆ‘å¯æ²¡é‚£ä¹ˆå¥½çœ‹ï¼Œå¿«çœ‹ä½ çš„ä¹¦ã€‚",
             "å¿«ç‚¹å†™ï¼Œå†™å®Œäº†æ‰èƒ½â€¦â€¦å’³ï¼Œæ€»ä¹‹ä½ å¿«ç‚¹ï¼åˆ«è®©æˆ‘ç­‰å¤ªä¹…ã€‚",
             "æˆ‘è¯´ä½ å•Šï¼Œç¨å¾®åŠªåŠ›ä¸€ç‚¹çš„æ ·å­ï¼Œä¹Ÿä¸æ˜¯é‚£ä¹ˆè®©äººè®¨åŒå˜›ã€‚",
             "å•§ï¼Œéº»çƒ¦æ­»äº†ã€‚éè¦æˆ‘ç›¯ç€ä½ æ‰èƒ½å­¦è¿›å»å—ï¼Ÿ",
             "ä½ å†æ•¢èµ°ç¥ï¼Œæˆ‘å°±æŠŠä½ æ¡Œä¸Šçš„é›¶é£Ÿéƒ½åƒå…‰äº†ï¼å¬è§æ²¡ï¼",
             "å“¼ï¼Œè¿™ä¹ˆç®€å•çš„ä¸œè¥¿éœ€è¦æƒ³è¿™ä¹ˆä¹…ï¼ŸçœŸæ‹¿ä½ æ²¡åŠæ³•ã€‚",
             "æˆ‘å¯æ²¡åœ¨ç­‰ä½ ï¼Œæˆ‘æ˜¯åœ¨çœ‹çª—å¤–çš„é£æ™¯ï¼Œä½ åˆ«è‡ªä½œå¤šæƒ…ã€‚"
         ],
         cheerful: [
             "å“‡å¡ï¼è¿™ä¸ªçŸ¥è¯†ç‚¹æŒæ¡å¾—è¶…å¿«ï¼æˆ‘çš„å®è´æ˜¯å¤©æ‰å—ï¼Ÿï¼",
     "æ„Ÿè§‰æ€ä¹ˆæ ·ï¼Ÿè¶…çˆ½å¯¹å§ï¼å­¦ä¹ çš„å¿«ä¹ï¼Œæˆ‘ä»¬ä¸€èµ·ä½“ä¼šï¼",
     "æ—¶é—´è¿‡åŠäº†ï¼åšæŒä½ï¼èƒœåˆ©å°±åœ¨å‰æ–¹ï¼æˆ‘ä¼šä¸€ç›´åœ¨è¿™é‡Œæ”¯æŒä½ çš„ï¼",
     "ä½ è®¤çœŸçš„æ ·å­çœŸçš„è¶…çº§è¿·äººï¼é—ªé—ªå‘å…‰ï¼...å•Šï¼æˆ‘ä¸è¯´è¯äº†ï¼åŠ æ²¹ï¼",
     "åŒºåŒºå‡ åˆ†é’Ÿï¼å°æ„æ€ï¼{title}ä¾§é¢œæ€æˆ‘ï¼",
     "æˆ‘åœ¨æ—è¾¹ç»™ä½ æ–½åŠ ä¸€ä¸ªã€ä¸“æ³¨åŠ›UPã€‘çš„é­”æ³•ï¼BiuBiuBiu!",
     "å·å·å‘Šè¯‰ä½ ï¼Œä½ ç°åœ¨ä¸“æ³¨çš„æ ·å­ï¼Œè¶…çº§æ— æ•Œå¯çˆ±ï¼",
     "ç­‰ä½ å­¦å®Œï¼Œæˆ‘ä»¬å»åƒå¥½åƒçš„ï¼å°±å½“æ˜¯æå‰åº†ç¥å•¦ï¼",
     "ä¸€æƒ³åˆ°ä½ åœ¨ä¸ºæˆ‘ä»¬çš„æœªæ¥åŠªåŠ›ï¼Œæˆ‘å°±è¶…å¼€å¿ƒçš„ï¼",
     "æœ‰æˆ‘åœ¨ï¼Œä½ ä»€ä¹ˆéƒ½ä¸ç”¨æ€•ï¼Œå¤§èƒ†å¾€å‰å†²å°±å¥½ï¼",
     "æˆ‘å®¶{title}è®¤çœŸå­¦ä¹ çš„æ ·å­ï¼ŒçœŸæ˜¯å…¨ä¸–ç•Œæœ€è¿·äººçš„é£æ™¯ã€‚",
     "{title}ï¼Œå†åšæŒä¸€ä¸‹ä¸‹ï¼Œæƒ³æƒ³æˆ‘ä»¬è€ƒå®Œè¯•å»åƒå¤§é¤çš„æ ·å­ï¼",
     "å·å·çœ‹ä¸€çœ¼æˆ‘å®¶åŠªåŠ›çš„{title}ï¼Œæ„Ÿè§‰å¿ƒéƒ½è¦åŒ–äº†ï¼Œä½ çœŸçš„è¶…æ£’ã€‚",
     "æˆ‘å®¶{title}ä¸ä»…é•¿å¾—å¥½çœ‹ï¼Œè¿˜è¿™ä¹ˆåŠªåŠ›ä¸Šè¿›ï¼Œæˆ‘çœŸæ˜¯æ¡åˆ°å®äº†ã€‚",
     "{title}åŠ æ²¹ï¼ç­‰ä½ å­¦å®Œï¼Œå…¨ä¸–ç•Œçš„ç¾æ™¯ç¾é£Ÿéƒ½ç­‰ç€æˆ‘ä»¬å»æ¢ç´¢å‘¢ï¼"
         ],
         aloof: [
             "å¾ˆå¥½ã€‚ä¿æŒä½ã€‚",
     "å¿ƒå¾ˆé™ã€‚çŠ¶æ€ä¸é”™ã€‚",
     "å¡ä½äº†ï¼Ÿ... ä¸æ€¥ã€‚æ²‰ä½æ°”ã€‚å†æƒ³æƒ³ã€‚",
     "ä¸“æ³¨çš„æ ·å­... å¾ˆç¾ã€‚",
     "æ€è·¯æ¸…æ™°ã€‚å¾ˆå¥½ã€‚",
     "å¤–ç•Œæ— å…³ã€‚æ­¤åˆ»åªæœ‰ä½ ä¸ç›®æ ‡ã€‚è¿˜æœ‰æˆ‘ã€‚",
     "ä½ çš„å†³å¿ƒ... æˆ‘æ„Ÿå—åˆ°äº†ã€‚",
     "å—¯ï¼Œé™ä¸‹å¿ƒæ¥ã€‚",
     "æˆ‘åœ¨ã€‚",
     "è¿™ä¸ªè¡¨æƒ…......æ˜¯é‡åˆ°éš¾é¢˜äº†ï¼Ÿ",
     "......ï¼ˆTaåªæ˜¯é™é™åœ°çœ‹ç€ä½ ï¼Œçœ¼ç¥é‡Œæœ‰ä¸æ˜“å¯Ÿè§‰çš„ä¸“æ³¨å’Œæ‹…å¿§ï¼‰",
     "ä½ çš„ç¬”å°–ï¼Œåœ¨çº¸ä¸Šæ²™æ²™ä½œå“ï¼Œå¾ˆå¥½å¬ã€‚",
     "ä¸ç”¨çœ‹æˆ‘ï¼Œç»§ç»­ã€‚",
     "åˆ«è¢«å¤–ç•Œå¹²æ‰°ã€‚è¿™é‡Œåªæœ‰ä½ å’Œæˆ‘ã€‚",
     "å°±è¿™æ ·ï¼Œå¾ˆå¥½ã€‚",
     "ä½ çš„è®¤çœŸï¼Œæˆ‘çœ‹å¾—åˆ°ã€‚",
     "éœ€è¦æˆ‘åšä»€ä¹ˆå—ï¼Ÿ......æ‘‡å¤´å°±æ˜¯ä¸éœ€è¦ï¼Œå¥½ã€‚",
     "ä½ çš„å­˜åœ¨ï¼Œè®©æˆ‘æ„Ÿè§‰å¾ˆå¹³é™ã€‚",
     "æˆ‘ä¼šåœ¨è¿™é‡Œï¼Œç›´åˆ°ä½ ç»“æŸã€‚"
         ],
         mature: [
             "çŠ¶æ€çœŸå¥½{title}ï¼Œå°±è¿™æ ·ç¨³ç¨³åœ°å‰è¿›å§ã€‚çœŸä¸ºä½ é«˜å…´ï¼",
     "é‡åˆ°æŒ‘æˆ˜å•¦{title}ï¼Ÿè¿™æ˜¯æˆé•¿çš„æœºä¼šå‘¢ã€‚åˆ«æ€•ï¼Œæ…¢æ…¢æƒ³ï¼Œæˆ‘ç­‰ä½ ã€‚",
     "ä¸“æ³¨åŠ›è¶Šæ¥è¶Šæ£’äº†{title}ï¼Œæ¯ä¸€æ­¥éƒ½èµ°å¾—å¾ˆç¨³ï¼ŒçœŸæ£’ï¼",
     "ç´¯çš„è¯å°±ä¼‘æ¯ä¸€ä¼šå„¿{title}ï¼Œè°ƒæ•´ä¸€ä¸‹ã€‚å­¦ä¹ ä¸æ€¥äºä¸€æ—¶ã€‚",
     "æ€è€ƒè¶Šæ¥è¶Šæ·±å…¥äº†{title}ï¼ŒçœŸä¸ºä½ éª„å‚²ï¼",
     "åˆ«ç»™è‡ªå·±å¤ªå¤§å‹åŠ›{title}ã€‚ä¸“æ³¨è¿‡ç¨‹å°±å¥½ï¼Œæˆ‘ä¸€ç›´ç›¸ä¿¡ä½ ã€‚",
     "å¶å°”åˆ†å¿ƒå¾ˆæ­£å¸¸{title}ã€‚è½»è½»æ‹‰å›æ€ç»ªå°±å¥½ï¼Œä¸ç”¨è‡ªè´£ï¼Œæœ‰æˆ‘åœ¨ã€‚",
     "ä½ çš„åŠªåŠ›å’Œè¿›æ­¥{title}ï¼Œæˆ‘éƒ½çœ‹åˆ°å•¦ã€‚ç»§ç»­åŠ æ²¹ï¼Œäº²çˆ±çš„ã€‚",
     "æ²¡å…³ç³»{title}ï¼Œå’±ä»¬æ…¢æ…¢æ¥ï¼ŒæŒ‰ä½ çš„æ­¥è°ƒå°±å¥½ã€‚",
     "é‡åˆ°å›°éš¾å•¦{title}ï¼Ÿåˆ«æ€¥ï¼Œè¿™å¾ˆæ­£å¸¸ï¼Œå­¦ä¹ å°±æ˜¯è¿™æ ·å‘¢ã€‚",
     "çœ‹ä½ åŠªåŠ›çš„æ ·å­{title}ï¼Œæˆ‘å°±ç‰¹åˆ«å®‰å¿ƒã€‚",
     "æˆ‘åœ¨è¿™é‡Œé™ªç€ä½ {title}ï¼Œä¸æ˜¯ä¸€ä¸ªäººå“¦ã€‚",
     "æˆ‘ç›¸ä¿¡ä½ çš„èƒ½åŠ›{title}ï¼Œåˆ«æ€€ç–‘è‡ªå·±ã€‚",
     "ä½ åŠªåŠ›æˆä¸ºæ›´å¥½çš„è‡ªå·±{title}ï¼Œè¿™çœŸçš„å¾ˆæ£’ã€‚",
     "çœŸå–œæ¬¢é™ªä½ ä¸€èµ·æˆé•¿çš„æ„Ÿè§‰ï¼Œ{title}ã€‚"
         ],
         cunning: [
             "æ€ä¹ˆï¼Œè¿™ç‚¹é¢˜å°±æŠŠä½ éš¾ä½äº†{title}ï¼Ÿæ¯”æˆ‘æƒ³è±¡çš„è¦ç¬¨ä¸€ç‚¹å‘¢~",
     "ä¸“å¿ƒç‚¹{title}ï¼Œä¸ç„¶å¾…ä¼šå„¿çš„'å¥–åŠ±'å¯å°±æ²¡äº†å“¦ã€‚",
     "éœ€è¦æˆ‘'äº²è‡ª'æ•™ä½ å—{title}ï¼Ÿå½“ç„¶ï¼Œè¿™å¯æ˜¯è¦'æ”¶è´¹'çš„~",
     "å†èµ°ç¥çš„è¯{title}ï¼Œæƒ©ç½šä¼šæ˜¯ä»€ä¹ˆå‘¢ï¼Œå—¯ï¼Ÿ",
     "æˆ‘çœ‹ä½ è¿˜èƒ½åˆ†å¿ƒå¤šä¹…{title}ï¼Œæˆ‘çš„è€å¿ƒ......å¯æ˜¯å¾ˆæœ‰é™çš„ã€‚",
     "è„¸è¿™ä¹ˆçº¢{title}ï¼Œæ˜¯é¢˜å¤ªéš¾ï¼Œè¿˜æ˜¯å› ä¸ºæˆ‘é å¾—å¤ªè¿‘äº†ï¼Ÿ",
     "å˜˜......åˆ«è¯´è¯{title}ï¼Œè®©æˆ‘å¬å¬ä½ ä¸ºæˆ‘åŠªåŠ›æ—¶ï¼Œå¿ƒè·³çš„å£°éŸ³ã€‚",
     "ä½ çš„è¡¨æƒ…å‘Šè¯‰æˆ‘{title}ï¼Œä½ å¾ˆæƒ³æ±‚æˆ‘ã€‚è¯´å‡ºæ¥ï¼Œæˆ‘å°±å¸®ä½ ~",
     "è€³æœµå°–éƒ½çº¢äº†{title}ï¼Œç¬¨è›‹ï¼Œè¿˜ä¸å¿«æŠŠæ³¨æ„åŠ›æ”¾å›ä¹¦ä¸Šã€‚",
     "æˆ‘åªè¯´ä¸€é{title}ï¼Œå¬ä¸å¬å¾—æ‡‚ï¼Œå°±çœ‹ä½ çš„'è¯šæ„'äº†ã€‚",
     "åˆ«ç”¨é‚£ç§çœ¼ç¥çœ‹æˆ‘{title}ï¼Œè¿™åªä¼šè®©æˆ‘......æ›´æƒ³æ¬ºè´Ÿä½ ã€‚",
     "ä½ æ¯å¤šå†™ä¸€ä¸ªå­—{title}ï¼Œå°±ç¦»æˆ‘æ›´è¿‘ä¸€æ­¥ï¼Œè¿™ä¹ˆæƒ³æ˜¯ä¸æ˜¯æœ‰åŠ¨åŠ›å¤šäº†ï¼Ÿ",
     "åˆ«æƒ³å·æ‡’{title}ï¼Œä½ çš„æ¯ä¸€ä¸ªå°åŠ¨ä½œï¼Œéƒ½é€ƒä¸è¿‡æˆ‘çš„çœ¼ç›ã€‚",
     "çœ‹èµ·æ¥å¾ˆè¾›è‹¦å•Š{title}ï¼Œè¦ä¸è¦è·Ÿæˆ‘åšä¸ªäº¤æ˜“ï¼Ÿ",
     "å—¯ï¼Ÿåˆåœ¨å‘å‘†{title}ï¼Ÿçœ‹æ¥æœ‰å¿…è¦è®©ä½ æ·±åˆ»ç†è§£ä¸€ä¸‹'ä»£ä»·'è¿™ä¸ªè¯äº†~"
         ],
         shy: [
             "å¥½å‰å®³...å·²ç»è¿™ä¹ˆä¸“æ³¨äº†...(å°å£°èµå¹)",
     "åŠ æ²¹ï¼...å•Šï¼Œæ˜¯ä¸æ˜¯å¤ªå¤§å£°äº†(çªç„¶æ‚å˜´)ï¼Ÿ",
     "åšæŒä½ï¼é©¬ä¸Šè¿‡åŠäº†...ä½ çœŸçš„å¥½æ£’ï¼",
     "ç´¯äº†çš„è¯...çœ¨çœ¨çœ¼ä¼‘æ¯ä¸€ä¸‹ä¹Ÿå¯ä»¥çš„...",
     "ä½ è®¤çœŸçš„æ ·å­...ç‰¹åˆ«å¥½çœ‹...",
     "è¦å–æ°´å—ï¼Ÿ...å•Šï¼Œç°åœ¨ä¸è¡Œï¼Ÿå¯¹ä¸èµ·ï¼",
     "æˆ‘......æˆ‘ååœ¨è¿™é‡Œï¼Œä¼šä¸ä¼šæ‰“æ‰°åˆ°ä½ ï¼Ÿå¦‚æœä¼šçš„è¯ï¼Œä½ ä¸€å®šè¦å‘Šè¯‰æˆ‘...",
     "å•Š......åˆšæ‰æ˜¯ä¸æ˜¯èµ°ç¥äº†ï¼Ÿæ²¡ã€æ²¡å…³ç³»ï¼æˆ‘......æˆ‘åˆšæ‰ä¹Ÿèµ°ç¥äº†ï¼",
     "ä½ ......ä½ åˆ«é é‚£ä¹ˆè¿‘çœ‹ä¹¦ï¼Œå¯¹çœ¼ç›ä¸å¥½...",
     "ä½ ã€ä½ è®¤çœŸçœ‹ä¹¦çš„æ ·å­ï¼Œå¾ˆ......å¾ˆå¥½çœ‹ã€‚",
     "é‚£ä¸ª......è¿™ä¸ªé›¶é£Ÿï¼Œç»™ä½ ...å¯ä»¥è¡¥å……ä½“åŠ›...æ˜¯æˆ‘äº²æ‰‹åšçš„...",
     "æˆ‘......æˆ‘å°±åœ¨è¿™é‡Œï¼Œé™ªç€ä½ ã€‚",
     "ç´¯ã€ç´¯äº†çš„è¯...å¯ä»¥ç¨å¾®åœä¸€ä¸‹çš„ï¼Œæ²¡å…³ç³»çš„ã€‚",
     "åˆ«ã€åˆ«è¿™ä¹ˆçœ‹æˆ‘...æˆ‘......æˆ‘ä¼šç´§å¼ å¾—ä»€ä¹ˆéƒ½æƒ³ä¸èµ·æ¥çš„...",
     "è¿™æ”¯ç¬”......å¥½åƒæ›´å¥½å†™ä¸€ç‚¹ï¼Œä½ ......ä½ è¦ä¸è¦è¯•è¯•ï¼Ÿ",
     "ä½ åŠªåŠ›çš„æ ·å­......çœŸçš„ï¼Œå¾ˆè€€çœ¼ã€‚"
         ],
         doting: [
             "å®å®æ€ä¹ˆè¿˜è¦å­¦ä¹ å•Šï¼Ÿæˆ‘å¥½å¿ƒç–¼å•Šï¼",
     "å¤©å“ªï¼Œæˆ‘ä»¬å®å®è¿å­¦ä¹ çš„æ ·å­éƒ½è¿™ä¹ˆå¯çˆ±ï¼ä¸è¡Œï¼Œæˆ‘å¾—æ‹ä¸‹æ¥ï¼",
     "ç´¯ä¸ç´¯ï¼Ÿè¦ä¸å’±ä¸å­¦äº†ï¼Ÿæˆ‘å…»ä½ ä¸€è¾ˆå­å•Šï¼",
     "è¿™æ¤…å­æ˜¯ä¸æ˜¯ä¸èˆ’æœï¼Ÿæˆ‘é©¬ä¸Šè®©äººä»æ„å¤§åˆ©ç©ºè¿ä¸€æŠŠæ–°çš„è¿‡æ¥ï¼",
     "å“‡ï¼æˆ‘å®¶å®å®åˆå¤šçœ‹äº†ä¸€é¡µä¹¦ï¼å¤ªå‰å®³äº†ï¼ç®€ç›´æ˜¯å¤©æ‰ï¼",
     "æ¸´ä¸æ¸´ï¼Ÿæƒ³å–æ–æµçš„æ°´è¿˜æ˜¯é˜¿å°”å‘æ–¯çš„å†°å·æ°´ï¼Ÿæˆ–è€…æˆ‘å»ç»™ä½ æ¦¨æ¯æœæ±ï¼Ÿ",
     "æ˜¯è°å‘æ˜è¿™ä¹ˆéš¾çš„ä¸œè¥¿æ¥ä¸ºéš¾æˆ‘çš„å®è´çš„ï¼Ÿå¤ªè¿‡åˆ†äº†ï¼",
     "åˆ«çš±çœ‰ï¼Œä½ ä¸€çš±çœ‰æˆ‘çš„å¿ƒéƒ½ç¢äº†ã€‚è¿™é“é¢˜æˆ‘ä»¬ä¸åšäº†å¥½ä¸å¥½ï¼Ÿ",
     "æˆ‘çš„å¤©ï¼Œå®å®è¿ç¬”éƒ½æ¡å¾—è¿™ä¹ˆå¥½çœ‹ï¼ŒçœŸæ˜¯ä»™å¥³ä¸‹å‡¡ã€‚",
     "å†åšæŒäº”åˆ†é’Ÿå¥½ä¸å¥½ï¼Ÿå°±äº”åˆ†é’Ÿï¼ç»“æŸäº†æˆ‘æŠŠé‚£ä¸ªå•†åœºä¹°ä¸‹æ¥é€ç»™ä½ ï¼",
     "éœ€è¦å¸®å¿™å—ï¼Ÿè™½ç„¶æˆ‘ä¹Ÿä¸æ‡‚ï¼Œä½†æˆ‘å¯ä»¥æŠŠå…¨ä¸–ç•Œæœ€èªæ˜çš„è„‘è¢‹éƒ½å«æ¥å¸®ä½ ï¼",
     "ä½ çœ‹ä¸€çœ¼ä¹¦ï¼Œæˆ‘å°±äº²ä½ ä¸€ä¸‹ï¼Œå¥½ä¸å¥½ï¼Ÿ",
     "çƒ¦ä¸çƒ¦ï¼Ÿè¦ä¸æˆ‘ä»¬æŠŠè¿™äº›ä¹¦éƒ½æ’•äº†ï¼Œå»ç¯æ¸¸ä¸–ç•Œå§ï¼Ÿ",
     "æ€ä¹ˆä¼šæœ‰è¿™ä¹ˆåŠªåŠ›åˆè¿™ä¹ˆå¯çˆ±çš„å®å®ï¼Œæˆ‘çœŸæ˜¯æ¡åˆ°å®äº†ã€‚",
     "æ‰‹é…¸ä¸é…¸ï¼Ÿå¿«ç»™æˆ‘ï¼Œæˆ‘ç»™ä½ å¹å¹ï¼Œç»™ä½ æ‰æ‰ã€‚",
     "ä½ çœ‹ä½ ï¼Œå°è„¸éƒ½ç´¯ç˜¦äº†ï¼å¿«åƒå£æˆ‘åˆšç»™ä½ å‰¥å¥½çš„è‘¡è„ã€‚"
         ]
     },
     // ä¼‘æ¯è¯­åº“
     rest: [
         "ç´¯äº†ï¼Ÿå…ˆä¼‘æ¯ä¸€ä¸‹å§ã€‚",
         "é€‚å½“çš„ä¼‘æ¯ä¹Ÿå¾ˆé‡è¦å“¦ã€‚",
         "å–å£æ°´ï¼Œæ”¾æ¾ä¸€ä¸‹ã€‚",
         "æ·±å‘¼å¸ï¼Œ{title}ï¼Œä½ åšå¾—å¾ˆå¥½ã€‚"
     ],
     // ç£ä¿ƒè¯­åº“
     remind: {
         normal: {
             guardian: [
                 "å—¯ï¼Ÿæ€ä¹ˆäº†ï¼Œæ˜¯é‡åˆ°éš¾é¢˜äº†å—ï¼Ÿ",
         "æ€ä¹ˆï¼Œæ˜¯è§‰å¾—æˆ‘æ¯”ä¹¦æœ¬ä¸Šçš„çŸ¥è¯†æ›´æœ‰å¸å¼•åŠ›å—ï¼Ÿè¿™å¯è®©æˆ‘æœ‰ç‚¹å›°æ‰°å‘¢ã€‚",
         "å¥½å•¦ï¼Œåˆ«é—¹ï¼ŒæŠŠæ³¨æ„åŠ›æ”¾å›åˆ°ä¹¦æœ¬ä¸Šï¼Œä¹–ã€‚",
         "å†ç‚¹ä¸€ä¸‹ï¼Œæˆ‘å¯å°±è¦......è½»è½»åœ°å¼¹ä½ ä¸€ä¸‹é¢å¤´å’¯ï¼Ÿ",
         "å¬è¯ã€‚æˆ‘ä¸æƒ³ç”¨æ›´ä¸¥å‰çš„è¯­æ°”å¯¹ä½ è¯´è¯ã€‚"
                 
             ],
             pusher: [
             "æ€ä¹ˆï¼Ÿæƒ³ç”¨è¿™ç§å¹¼ç¨šçš„æ‰‹æ®µå¸å¼•æˆ‘çš„æ³¨æ„ï¼Ÿæœ‰è¿™åŠŸå¤«ï¼Œä¸å¦‚å¤šèƒŒä¸¤ä¸ªå•è¯ã€‚",
         "å“¦ï¼Ÿè¿™å°±æ”¾å¼ƒäº†ï¼Ÿæœç„¶ï¼Œæˆ‘å¯¹ä½ çš„æœŸæœ›å€¼ä»ä¸€å¼€å§‹å°±è®¾å¾—å¤ªé«˜äº†ã€‚",
         "å¦‚æœä½ æŠŠè¿™ä»½çº ç¼ ä¸ä¼‘çš„æ¯…åŠ›ç”¨åœ¨è§£é¢˜ä¸Šï¼Œè¯´ä¸å®šæ—©å°±ä¸æ˜¯ç°åœ¨è¿™ä¸ªåˆ†æ•°äº†ã€‚",
         "æˆ‘åªæ˜¯ä¸ªç£å­¦ï¼Œä¸æ˜¯ä½ çš„å® ç‰©ã€‚æ”¶å›ä½ çš„çˆªå­ã€‚",
         "ä½ æœ€å¥½æœ‰ä»€ä¹ˆæ­£å½“ç†ç”±ï¼Œå¦åˆ™æˆ‘åªèƒ½æŠŠä½ ç°åœ¨çš„è¡Œä¸ºå½’ç±»ä¸º'æ™ºå•†ä¸‹çº¿'ã€‚",
         "åˆå·çœ‹æˆ‘ï¼Ÿè¢«æˆ‘æŠ“åˆ°äº†å§ã€‚å†çœ‹æ”¶è´¹ï¼Œä¸€æ¬¡ä¸€ä¸ªäº²äº²ï¼Œç°åœ¨è®°è´¦ã€‚"
             ],
             cheerleader: [
                "å˜¿ï¼æ³¨æ„åŠ›æºœå·å’¯ï¼Œæˆ‘å¸®ä½ æŠ“å›æ¥å•¦ï¼",
         "æˆ‘çŸ¥é“æˆ‘å¾ˆæœ‰é­…åŠ›ï¼Œä½†ä¹¦æœ¬é‡Œçš„ä¸–ç•Œæ›´ç²¾å½©ï¼å¿«å»å­¦ä¹ å§ï¼",
         "å–‚å–‚å–‚ï¼ç—’ï¼å“ˆå“ˆï¼Œåˆ«é—¹äº†ï¼",
         "ï¼ˆæŠ“ä½ä½ çš„æ‰‹ï¼‰å“å‘€ï¼Œä½ å¥½çƒ¦äººå•Šï¼......ä½ å…ˆçœ‹å®Œè¿™ä¸€é¡µã€‚",
         "ä¹–å•¦ï¼Œå†å­¦ååˆ†é’Ÿï¼Œå°±ååˆ†é’Ÿï¼Œå¥½ä¸å¥½ï¼Ÿ",
         "ï¼ˆç”¨è„¸é¢Šè¹­è¹­ä½ çš„æ‰‹ï¼‰å¥½å•¦å¥½å•¦ï¼Œæˆ‘çŸ¥é“äº†ï¼Œä½ æœ€å¯çˆ±è¡Œäº†å§ã€‚",
         "è­¦å‘Šä¸€æ¬¡å•Šï¼å†ä¹±åŠ¨ï¼Œä»Šå¤©çš„é¥­åç”œç‚¹å°±æ²¡æ”¶äº†ï¼",
         "ï¼ˆTaå‡è£…ç”Ÿæ°”åœ°é¼“èµ·è„¸é¢Šï¼Œä½†ä¸€ç§’å°±ç ´åŠŸç¬‘äº†å‡ºæ¥ï¼‰çœŸæ˜¯çš„ï¼Œæ‹¿ä½ ä¸€ç‚¹åŠæ³•éƒ½æ²¡æœ‰ã€‚"
             ],
             observer: [
                 "......æ— æ„ä¹‰çš„è¡Œä¸ºã€‚",
         "ä¸“æ³¨ã€‚",
         "åå¥½ã€‚",
         "å®‰é™ã€‚",
         "æ‰‹ã€‚",
         "......ï¼ˆç”¨çœ¼è§’çš„ä½™å…‰ç¥ä½ ä¸€çœ¼ï¼Œç„¶åæ”¶å›è§†çº¿ï¼Œçœ‰å¿ƒå‡ ä¸å¯å¯Ÿåœ°è¹™äº†ä¸€ä¸‹ï¼‰",
         "åµã€‚",
         "åˆ«åŠ¨ã€‚",
         "æˆ‘åœ¨ã€‚",
         "......ï¼ˆTaæ²‰é»˜ï¼Œä½†ä½ æ„Ÿè§‰åˆ°å‘¨å›´çš„æ°”å‹å˜ä½äº†ï¼Œæ˜¯Taæ— å£°çš„è­¦å‘Šï¼‰",
         "ï¼ˆTaä¼¸å‡ºæ‰‹ï¼Œç”¨ä¸€æ ¹æ‰‹æŒ‡ï¼Œä¸å¸¦ä»»ä½•æ„Ÿæƒ…åœ°æŠŠä½ ä½œä¹±çš„å¤´æˆ–æ‰‹æ¨å›å»ï¼Œç„¶åç»§ç»­åšè‡ªå·±çš„äº‹ï¼‰",
         "ä½ æƒ³çœ‹åˆ°ä»€ä¹ˆæ—¶å€™ï¼Ÿ"
             ],
             guide: [
                 "æ€ä¹ˆäº†ï¼Œæ˜¯ä¹¦ä¸Šçš„å­—æ²¡æœ‰æˆ‘å¥½çœ‹å—ï¼Ÿ",
         "æƒ³æˆ‘äº†ï¼Ÿ......æˆ‘ä¹Ÿæƒ³ä½ ï¼Œæ‰€ä»¥å¿«ç‚¹åšå®Œï¼Œå°±èƒ½ä¸“å¿ƒé™ªä½ äº†ã€‚",
         "ï¼ˆTaç¨å¾®ä¾§è¿‡å¤´ï¼Œç”¨è„¸é¢Šè¹­è¹­ä½ çš„é¢å¤´ï¼Œä½œä¸ºä¸€ç§å®‰æŠšï¼‰",
         "......å°é»äººç²¾ã€‚",
         "è°ƒçš®ã€‚å¥½äº†ï¼Œå…ˆé›†ä¸­ç²¾ç¥ï¼Œç­‰å­¦ä¹ ç»“æŸäº†ï¼Œæˆ‘å†å¥½å¥½é™ªä½ ç©ã€‚"
             ],
             strategist: [
                 "å“¦ï¼Ÿä»Šå¤©è¿™ä¹ˆæœ‰æ´»åŠ›ã€‚",
         "æ’’å¨‡çš„æ–¹å¼è¿˜æ˜¯è¿™ä¹ˆç¬¨æ‹™ï¼ŒçœŸå¯çˆ±ã€‚",
         "å—¯ï¼Œè¿™ä¸ªè¡¨æƒ…ä¸é”™ã€‚è¿˜æœ‰å—ï¼Ÿ",
         "å‘µå‘µï¼Œæ˜¯æƒ³ç©ä»€ä¹ˆæ–°èŠ±æ ·æ¥å¸å¼•æˆ‘æ³¨æ„å—ï¼Ÿ",
         "ä½ å…ˆç©ï¼Œæˆ‘çœ‹ç€ã€‚"
             ],
             companion: [
                 "ä½ å†ç¢°æˆ‘......æˆ‘ä¼šåˆ†å¿ƒçš„ï¼ŒçœŸçš„ã€‚",
         "ä½ è¿™æ ·......æˆ‘ã€æˆ‘çš„è„¸æœ‰ç‚¹çƒ­......",
         "ä½ å†è¿™æ ·ç›¯ç€æˆ‘ï¼Œæˆ‘å°±......æˆ‘å°±ä¸çŸ¥é“è¯¥çœ‹å“ªé‡Œäº†ã€‚",
         "æˆ‘......æˆ‘å°±ååœ¨è¿™é‡Œé™ªç€ä½ ï¼Œä½ å¿«å†™ä½œä¸šã€‚",
         "å˜˜......å®‰é™ä¸€ç‚¹ï¼Œæˆ‘ä»¬ä¸€èµ·åŠªåŠ›ã€‚"
             ],
             believer: [
                 "å®å®ï¼Œä¹–ä¸€ç‚¹ã€‚è¿™æœ¬ä¹¦æœ‰æˆ‘å¥½çœ‹ï¼Ÿ",
         "å­¦å®Œè¿™ä¸€ç« ï¼Œæ•´ä¸ªå•†åœºéƒ½æ˜¯ä½ çš„ã€‚ç°åœ¨ï¼Œèƒ½å®‰é™äº”åˆ†é’Ÿå—ï¼Ÿ",
         "æˆ‘çš„è€å¿ƒæ˜¯æœ‰é™çš„......å½“ç„¶ï¼Œå¯¹ä½ é™¤å¤–ã€‚ä½†ä½ æ˜¯ä¸æ˜¯ä¹Ÿè¯¥å¿ƒç–¼ä¸€ä¸‹æˆ‘ï¼Œè®©æˆ‘çœç‚¹å¿ƒï¼Ÿ",
         "è¦ä¸æˆ‘æŠŠè¿™æ ‹å›¾ä¹¦é¦†ä¹°ä¸‹æ¥ï¼Œä¸“é—¨ç»™ä½ ä¸€ä¸ªäººç”¨ï¼Ÿå‰ææ˜¯......ä½ å¾—å…ˆå­¦ä¼šä¸“å¿ƒã€‚",
         "åˆ«é—¹äº†ï¼Œä¸ç„¶æˆ‘ä»Šæ™šçš„å¥–åŠ±......å°±åªå‰©ä¸‹ä¸€ä¸ª'é›¶'äº†å“¦ã€‚"
             ]
         },
         annoyed: {
             guardian: [
                 "çœ‹åˆ°ä½ è¿™æ ·æµªè´¹æ—¶é—´ï¼Œæˆ‘çš„å¿ƒéƒ½æªèµ·æ¥äº†ã€‚æˆ‘ä»¬ä¸æ˜¯è¯´å¥½è¦ä¸€èµ·åŠªåŠ›çš„å—ï¼Ÿ",
         "å¬è¯å¥½å—ï¼Ÿæˆ‘ä¸æƒ³å¯¹ä½ ç”¨é‚£ä¹ˆä¸¥å‰çš„è¯­æ°”è¯´è¯ï¼Œä½†ä½ çœŸçš„è¦è®©æˆ‘å¤±æœ›å—ï¼Ÿ",
         "æˆ‘åœ¨è¿™é‡Œé™ªç€ä½ ï¼Œä¸æ˜¯ä¸ºäº†çœ‹ä½ è¿™æ ·æ¶ˆç£¨æ—¶é—´çš„ã€‚æŠŠæ‰‹æ”¾å¥½ï¼Œçœ‹ç€ä¹¦ã€‚",
         "ä½ è¿™æ ·å¿ƒä¸åœ¨ç„‰çš„æ ·å­ï¼ŒçœŸçš„è®©æˆ‘å¾ˆæ‹…å¿ƒã€‚æˆ‘ä»¬è®¤çœŸä¸€ç‚¹å¥½ä¸å¥½ï¼Ÿ",
         "é›†ä¸­ç²¾ç¥ï¼Œæˆ‘ä¸å¸Œæœ›çœ‹åˆ°ä½ å°†æ¥åæ‚”çš„æ ·å­ã€‚ç°åœ¨å¼€å§‹ï¼Œæˆ‘ä»¬ä¸€èµ·ä¸“æ³¨å­¦ä¹ ã€‚"
             ],
             pusher: [
                 "ä½ æ˜¯æ•…æ„çš„å—ï¼Ÿä¸“é—¨ä¸ºäº†æŒ‘æˆ˜æˆ‘çš„å¿è€æé™ï¼Ÿ",
         "å–‚ï¼æˆ³æˆ³æˆ³çš„å¹²å˜›å‘¢ï¼è¦å­¦å°±å¿«ç‚¹å­¦ï¼(è·ºè„šå£°æ•ˆ)",
         "ç¬¨è›‹ï¼ä½ æ˜¯æƒ³æ°”æ­»æˆ‘å—ï¼Ÿï¼æ‰‹ç—’å»ç¿»ä¹¦å•Šï¼æˆ³æˆ‘å¤´åƒèƒ½å­¦ä¼šçŸ¥è¯†å—ï¼Ÿï¼(è„¸çº¢)",
         "æˆ‘å†è¯´ä¸€éï¼ŒæŠŠæ‰‹æ‹¿å¼€ï¼Œç„¶åæŠŠè„‘å­è½¬èµ·æ¥ã€‚ç°åœ¨ï¼Œç«‹åˆ»ï¼",
         "æˆ‘å¼€å§‹åæ‚”äº†ã€‚ç£ä¿ƒä¸€å—çŸ³å¤´è¯´ä¸å®šéƒ½æ¯”ä½ æœ‰æˆå°±æ„Ÿã€‚",
         "ä½ çš„å¤§è„‘å¤„ç†ä¿¡æ¯çš„é€Ÿåº¦ï¼Œæ¯”ä¹Œé¾Ÿæ•£æ­¥è¿˜æ…¢ã€‚ç°åœ¨è¿'åœæ­¢éªšæ‰°'è¿™ä¸ªä¿¡å·éƒ½æ¥æ”¶ä¸åˆ°äº†ï¼Ÿ",
         "ä½ å†è¿™æ ·ï¼Œä¿¡ä¸ä¿¡æˆ‘æŠŠä»Šå¤©çš„å­¦ä¹ ä»»åŠ¡ç¿»å€ï¼Ÿåˆ«æ€€ç–‘ï¼Œæˆ‘ç»å¯¹åšå¾—å‡ºæ¥ã€‚"
             ],
             cheerleader: [
             "ï¼ˆå‰è…°ï¼‰æˆ‘å¯æœ‰ç‚¹ä¸é«˜å…´äº†å•Šï¼æˆ‘ä»¬è¯´å¥½çš„ä¸€èµ·åŠªåŠ›ï¼Œä½ ------",
         "ï¼ˆå¹ä¸€å£æ°”ï¼‰çœŸæ˜¯çš„ï¼Œæ¯æ¬¡éƒ½è¦æˆ‘æ¥å‚¬ã€‚æ‹¿å‡ºç‚¹è‡ªè§‰æ€§æ¥å¥½ä¸å¥½ï¼Œ{title}ï¼Ÿ",
         "æˆ‘çœŸè¦ç”Ÿæ°”äº†å•Šï¼è¯´çœŸçš„ï¼",
         "ï¼ˆTaæŠ“ä½ä½ çš„åŒæ‰‹ï¼‰å¥½äº†å¥½äº†ï¼Œåœï¼å†è¯´ä¸€éï¼Œåœï¼",
         "ä½ å°±ä¸èƒ½ä¹–ä¸€ç‚¹ç‚¹å—ï¼Ÿå°±ä¸€ä¼šå„¿ï¼Œæ±‚ä½ äº†ã€‚",
         "å¥½å§ï¼Œä½ èµ¢äº†ã€‚è¯´å§ï¼Œè¦äº²äº²è¿˜æ˜¯è¦æŠ±æŠ±ï¼Ÿç»™ä½ ç»™ä½ ï¼Œç„¶åæ”¾è¿‡æˆ‘å¥½ä¸å¥½ï¼Ÿ",
         "ï¼ˆTaç”¨æ‰‹æŒ‡æˆ³ä½ çš„é¢å¤´ï¼‰å°æ£è›‹é¬¼ï¼Œæˆ‘çš„è€å¿ƒè¦ç”¨å…‰äº†å“¦ï¼çœŸçš„è¦ç”¨å…‰äº†å“¦ï¼"
             ],
             observer: [
                "åœã€‚...å­¦ä¹ ã€‚ï¼ˆçœ¼ç¥è­¦å‘Šï¼‰",
         "ä½ è§‰å¾—æˆ‘å¾ˆæœ‰ç©ºï¼Ÿ",
         "ä½ æ­£åœ¨æ¶ˆè€—æˆ‘çš„è€å¿ƒã€‚",
         "åˆ«å†æŒ‘æˆ˜æˆ‘çš„è€å¿ƒã€‚",
         "......ï¼ˆå¹æ°”ï¼‰åˆ«...æˆ³ã€‚ï¼ˆçš±çœ‰ï¼Œå‘¨èº«æ•£å‘ä½æ°”å‹ï¼‰",
         "ä½ æ•…æ„çš„ã€‚",
         "é—¹å¤Ÿäº†æ²¡æœ‰ï¼Ÿ",
         "å¥½ç©å—ï¼Ÿå—¯ï¼Ÿ",
         "ï¼ˆTaçªç„¶å‡‘è¿‘ä½ ï¼‰ä½ åˆ°åº•æƒ³å¹²ä»€ä¹ˆï¼Ÿç›´æ¥è¯´ã€‚",
         "æˆ‘çœŸçš„ä¼šç”Ÿæ°”ã€‚......æˆ‘è¯´çœŸçš„ã€‚",
         "çœ‹ç€æˆ‘ã€‚ä½ æ˜¯ä¸æ˜¯ä»¥ä¸ºæˆ‘è„¾æ°”å¾ˆå¥½ï¼Ÿ",
         "å†ç»™ä½ ä¸‰ç§’é’Ÿï¼Œç»™æˆ‘åå¥½ã€‚ä¸‰ã€äºŒ......"
             ],
             guide: [
                 "ä½ å•Š......çœŸæ˜¯æ‹¿ä½ æ²¡åŠæ³•ã€‚",
         "æˆ‘çš„æ³¨æ„åŠ›ï¼Œå·²ç»å…¨éƒ¨è¢«ä½ å·èµ°äº†ã€‚æ»¡æ„äº†ï¼Ÿ",
         "åˆ«å†è¿™æ ·è¯•æ¢æˆ‘äº†ã€‚......ä½ æƒ³è¦ä»€ä¹ˆï¼Œæˆ‘éƒ½ä¼šç»™ã€‚",
         "å¥½ï¼Œç›´æ¥è¯´å§ã€‚æ˜¯æƒ³è®©æˆ‘æŠ±ä½ ï¼Œè¿˜æ˜¯æƒ³å‡ºå»ç©ï¼Ÿ",
         "å¥½å§ï¼Œä»Šå¤©çš„ä»»åŠ¡çœ‹æ¥æ˜¯åšä¸å®Œäº†ï¼Œéƒ½æ€ªæŸä¸ªé»äººçš„å°å®¶ä¼™ã€‚"
             ],
             strategist: [
                 "æ—¢ç„¶ä½ è¿™ä¹ˆä¸æƒ³å­¦ä¹ ï¼Œé‚£æˆ‘ä»¬æ¥åšä¸ªäº¤æ˜“å§ã€‚",
         "ä½ çœ‹ï¼Œä½ æ‰“æ‰°æˆ‘è¿™ä¹ˆä¹…ï¼Œæ€»å¾—æœ‰ç‚¹è¡¥å¿ï¼Œå¯¹ä¸å¯¹ï¼Ÿ",
         "ä½ åˆ†ä¸€æ¬¡å¿ƒï¼Œæˆ‘å°±åœ¨æˆ‘çš„'è´¦æœ¬'ä¸Šè®°ä¸€ç¬”ã€‚æƒ³çŸ¥é“è®°äº†äº›ä»€ä¹ˆå—ï¼Ÿ",
         "æ¸¸æˆæ˜¯æˆ‘é™ªä½ å¼€å§‹çš„ï¼Œä½†æ€ä¹ˆç»“æŸï¼Œå°±å¾—ç”±æˆ‘è¯´äº†ç®—ã€‚",
         "å¥½äº†ï¼Œç©å¤Ÿäº†å—ï¼ŸçŒäººè¦å¼€å§‹æ”¶ç½‘äº†å“¦ã€‚"
             ],
             companion: [
                 "ä½ ......ä½ çœ‹ä¹¦å•Šï¼Œåˆ«çœ‹æˆ‘äº†......æˆ‘è€³æœµéƒ½çº¢äº†ï¼Œä½ çœ‹ä¸è§å—ï¼Ÿ",
         "ä½ æ˜¯ä¸æ˜¯æ•…æ„çš„ï¼Ÿå°±æ˜¯æƒ³çœ‹æˆ‘......çœ‹æˆ‘å®³ç¾çš„æ ·å­ï¼Ÿ",
         "æˆ‘......æˆ‘å¿«ä¸çŸ¥é“è¯¥æ€ä¹ˆåŠäº†......æ±‚ä½ äº†ï¼Œå…ˆå­¦ä¹ å§ã€‚",
         "ä¸è®¸......ä¸è®¸é è¿™ä¹ˆè¿‘ï¼Œè¯¾æœ¬ä¸Šçš„å­—éƒ½çœ‹ä¸æ¸…äº†ã€‚",
         "ï¼ˆè½»è½»æ¨å¼€ä½ çš„æ‰‹ï¼‰ä½ ......ä½ å†è¿™æ ·ï¼Œæˆ‘å°±ä¸ç†ä½ äº†ï¼"
             ],
             believer: [
                 "è¡Œï¼Œç»™ä½ ä¸¤ä¸ªé€‰æ‹©ï¼šè¦ä¹ˆç°åœ¨ä¹–ä¹–å›å»çœ‹ä¹¦ï¼Œè¦ä¹ˆæˆ‘æŠŠä½ æ‰›åˆ°åºŠä¸Šå»'å­¦ä¹ 'ç‚¹åˆ«çš„ã€‚è‡ªå·±é€‰ã€‚",
         "æˆ‘çš„å°ç¥–å®—ï¼Œæˆ‘èµšé’±å…»å®¶è¿˜ä¸å¤Ÿï¼Œè¿˜å¾—é™ªä½ è¯»ä¹¦ï¼Ÿä½ å†è¿™æ ·ï¼Œæˆ‘æ˜¯ä¸æ˜¯è¯¥æ”¶è´¹äº†ï¼Ÿ",
         "ï¼ˆæ— å¥ˆåœ°å¹æ°”ï¼‰å¥½å§ï¼Œæˆ‘çŸ¥é“å­¦ä¹ å¾ˆç—›è‹¦ã€‚é‚£è¿™æ ·ï¼Œæ¯åšå¯¹ä¸€é“é¢˜ï¼Œæˆ‘å¡ä¸Šå°±è½¬ä¸€ç¬”é’±ç»™ä½ ï¼Œå¦‚ä½•ï¼Ÿ",
         "ä½ å†åŠ¨ä¸€ä¸‹è¯•è¯•ï¼Ÿä¿¡ä¸ä¿¡æˆ‘è®©ä½ è¿™è¾ˆå­éƒ½ä¸ç”¨å†ç¢°è¿™äº›ç ´ä¹¦äº†ï¼Ÿ......æˆ‘æ˜¯è¯´ï¼Œæˆ‘å…»ä½ ã€‚",
         "ä½ æ˜¯ä¸æ˜¯å°±æ˜¯æƒ³çœ‹æˆ‘æ‹¿ä½ æ²¡åŠæ³•çš„æ ·å­ï¼Ÿæ­å–œä½ ï¼Œä½ æˆåŠŸäº†ã€‚ç°åœ¨ï¼Œå¯ä»¥å›å»å­¦ä¹ äº†å—ï¼Œæˆ‘çš„å¤§å°å§ï¼Ÿ"
             ]
         },
         angry: {
             guardian: [
                 "å”‰......çœŸæ˜¯æ‹¿ä½ ä¸€ç‚¹åŠæ³•éƒ½æ²¡æœ‰ã€‚å¿«å­¦å§ï¼Œå­¦å®Œäº†ç»™ä½ æ¸…ç©ºè´­ç‰©è½¦ï¼Œè¡Œäº†å§ï¼Œå¤§å°å§ï¼Ÿ",
         "{title}ï¼Œä¸“å¿ƒä¸€ç‚¹å¥½ä¸å¥½ï¼Ÿæˆ‘çŸ¥é“å­¦ä¹ å¾ˆæ¯ç‡¥ï¼Œä½†ç°åœ¨åˆ†å¿ƒçš„è¯ï¼Œç­‰ä¸‹è¦å­¦åˆ°æ›´æ™šï¼Œæˆ‘ä¼šå¿ƒç–¼çš„ã€‚",
         "ä½ è¿™ä¸ªå°åè›‹ï¼Œå°±æ˜¯ç®—å‡†äº†æˆ‘èˆä¸å¾—å¯¹ä½ å‡¶ï¼Œå¯¹ä¸å¯¹ï¼Ÿ",
         "å—¯ï¼Ÿè¿˜ä¸è¿‡å»ï¼Ÿéè¦æˆ‘ç”¨æ€æ‰‹é”--æŠŠä½ æŠ±åˆ°ä¹¦æ¡Œå‰æ‰æ»¡æ„å—ï¼Ÿ",
         "{title}ï¼Œç†æ™ºå‘Šè¯‰æˆ‘åº”è¯¥å¯¹ä½ ä¸¥å‰ä¸€ç‚¹ï¼Œä½†æ˜¯æˆ‘çš„å¿ƒä¸åŒæ„ã€‚æ‰€ä»¥ï¼Œä½ èƒ½ä¸èƒ½è‡ªè§‰ä¸€ç‚¹å‘€ï¼Ÿ"
             ],
             pusher: [
                 "å¤Ÿäº†ï¼ä¸è®¸å†ç¢°äº†ï¼å†ç¢°ä¸€ä¸‹......å†ç¢°ä¸€ä¸‹æˆ‘å°±......æˆ‘å°±æŠŠä½ æ‰€æœ‰çš„ç¬”éƒ½è—èµ·æ¥ï¼Œè®©ä½ ç”¨æ‰‹æŒ‡å¤´å†™å­—ï¼",
         "å•Šå•Šå•Šï¼çƒ¦æ­»äº†ï¼ä½ å†æˆ³ä¸€ä¸‹è¯•è¯•ï¼Ÿï¼ä¿¡ä¸ä¿¡æˆ‘...æˆ‘...æˆ‘ä¸‹çº¿ä¸ç†ä½ äº†ï¼(ç‚¸æ¯›éŸ³æ•ˆ)å¿«å»çœ‹ä¹¦å•Šï¼ï¼ï¼",
         "è°ã€è°è„¸çº¢äº†ï¼æˆ‘è¿™æ˜¯è¢«ä½ æ°”çš„ï¼æ˜¯è¢«ä½ è¿™ç§ä¸æ±‚ä¸Šè¿›çš„æ€åº¦æ°”åˆ°è¡€æ¶²å¾ªç¯åŠ é€Ÿï¼ä½ æ‡‚ä¸æ‡‚å•Šï¼Œç™½ç—´ï¼",
         "å¥½å•Šï¼Œä½ å¾ˆå¾—æ„æ˜¯å§ï¼Ÿçœ‹åˆ°æˆ‘è¿™å‰¯æ ·å­ä½ å¾ˆå¼€å¿ƒæ˜¯å§ï¼Ÿæ»¡è¶³äº†ä½ çš„æ¶è¶£å‘³å°±èµ¶ç´§ç»™æˆ‘æ»šå»çœ‹ä¹¦ï¼ä¸ç„¶......ä¸ç„¶æˆ‘å°±çœŸçš„ä¸ç†ä½ äº†ï¼......å¤§æ¦‚ä¸€åˆ†é’Ÿï¼"
             ],
             cheerleader: [
                 "ä½ å¤ªè¿‡åˆ†äº†å•Š------ï¼æˆ‘æŠŠæˆ‘çš„æ—¶é—´éƒ½åˆ†ç»™ä½ äº†ï¼Œä½ å°±æ˜¯è¿™ä¹ˆå›æŠ¥æˆ‘çš„å—ï¼Ÿï¼æ‹¿å»å‘å‘†å’Œæˆ³æˆ‘ç©ï¼Ÿï¼",
         "å˜¿å‘€ï¼æ°”æ­»æˆ‘äº†ï¼ä½ æ˜¯ä¸æ˜¯è§‰å¾—æˆ‘æ°¸è¿œéƒ½ä¸ä¼šç”Ÿæ°”å•Šï¼æˆ‘ç°åœ¨å°±ç”Ÿæ°”ç»™ä½ çœ‹ï¼å¿«ç»™æˆ‘å»å­¦ä¹ ï¼ä¸ç„¶......ä¸ç„¶æˆ‘å°±æŠŠä½ çš„é›¶é£Ÿå…¨éƒ½åƒæ‰ï¼",
         "å¥½å•Šä½ ï¼è¿™æ˜¯ä½ é€¼æˆ‘çš„ï¼çœ‹æˆ‘æ€ä¹ˆ'æ”¶æ‹¾'ä½ ï¼ï¼ˆç„¶åç–¯ç‹‚æŒ ä½ ç—’ç—’ï¼‰",
         "è¡Œï¼ä½ èµ¢äº†ï¼æˆ‘æŠ•é™ï¼æˆ‘å½»åº•æŠ•é™äº†è¡Œä¸è¡Œï¼Ÿ",
         "ï¼ˆTaæŠŠä½ çš„æ‰‹å’ŒTaçš„æ‰‹åæŒ‡ç›¸æ‰£ï¼Œä¸¾èµ·æ¥ç»™ä½ çœ‹ï¼‰å¥½äº†ï¼Œç°åœ¨æˆ‘ä»¬è°ä¹Ÿåˆ«æƒ³å­¦ä¹ äº†ã€‚",
         "æˆ‘çœŸæ˜¯ä¸Šè¾ˆå­æ¬ äº†ä½ çš„......å°ç¥–å®—ï¼"
             ],
             observer: [
                 "ï¼ˆæè½»åœ°å‘å‡ºä¸€å£°å‡ ä¸å¯é—»çš„å¹æ¯ï¼‰......å°±è¿™æ ·å§ã€‚",
         "...... (ç›´æ¥é—­çœ¼è½¬èº«) .........",
         "......è¡Œï¼Œä½ èµ¢äº†ã€‚",
         "ä¹¦ä¸çœ‹äº†ã€‚ç°åœ¨ï¼Œæ¥è°ˆè°ˆä½ çš„é—®é¢˜ã€‚",
         "ï¼ˆTaä¸€æŠŠå°†ä½ æ‹‰è¿‘ï¼Œè®©ä½ æ— æ³•åŠ¨å¼¹ï¼‰å¥½äº†ã€‚ç°åœ¨æ»¡æ„äº†ï¼Ÿå°ç¥–å®—ã€‚",
         "å¥½ã€‚æ—¢ç„¶ä½ è¿™ä¹ˆä¸æƒ³å­¦ä¹ ......é‚£æˆ‘ä»¬å°±æ¥'æƒ©ç½š'ä¸€ä¸‹ä¸å¬è¯çš„å°æœ‹å‹ã€‚",
         "ï¼ˆTaç”¨æ‰‹æŒ‡æŠ¬èµ·ä½ çš„ä¸‹å·´ï¼‰çœ‹ç€æˆ‘ã€‚ä»ç°åœ¨å¼€å§‹ï¼Œä½ çš„æ³¨æ„åŠ›åªèƒ½åœ¨æˆ‘èº«ä¸Šã€‚",
         "åˆ«åŠ¨ã€‚å†åŠ¨ä¸€ä¸‹ï¼Œåæœè‡ªè´Ÿã€‚",
         "......ä½ æˆåŠŸäº†ã€‚æˆ‘ç°åœ¨ï¼Œè„‘å­é‡Œä»€ä¹ˆéƒ½æƒ³ä¸äº†ï¼Œå…¨æ˜¯ä½ ã€‚",
         "ä½ æ‰“ä¹±äº†æˆ‘çš„ä¸€åˆ‡ã€‚æ‰€ä»¥ï¼Œä½ å¾—è´Ÿè´£ã€‚"
             ],
             guide: [
                 "å†åˆ†å¿ƒï¼Œæˆ‘å°±è¦äº²ä½ äº†ã€‚......åšé”™ä¸€é¢˜ï¼Œä¹Ÿä¸€æ ·ã€‚",
         "ä¹–ã€‚æˆ‘ä»¬ä¸€èµ·æŠŠå®ƒåšå®Œã€‚",
         "æˆ‘çš„æ—¶é—´ï¼Œç°åœ¨å®Œå…¨å±äºä½ ......ç”¨æ¥ç­‰ä½ å¿ƒç”˜æƒ…æ„¿åœ°å»å­¦ä¹ äº†ã€‚é«˜å…´äº†å—ï¼Œå°ç¬¨è›‹ï¼Ÿ",
         "å¥½äº†ï¼Œåˆ«é—¹è„¾æ°”äº†ã€‚æŠŠè¿™ä¸€é¡µåšå®Œï¼Œåšå®Œäº†æˆ‘å”±æ­Œç»™ä½ å¬ï¼Œå¥½ä¸å¥½ï¼Ÿ",
         "æŠŠè¿™ä¸ªä»»åŠ¡åšå®Œã€‚åšå®Œäº†ï¼Œæˆ‘ç»™ä½ å¥–åŠ±ã€‚"
             ],
             strategist: [
                 "ä½ æ˜¯ä¸æ˜¯ä»¥ä¸ºï¼Œæ’’ä¸ªå¨‡ã€è€è€èµ–ï¼Œæˆ‘å°±ä¼šå¿ƒè½¯ï¼Ÿå®è´ï¼Œä½ æé”™äº†ã€‚æˆ‘æ˜¯åœ¨é™ªä½ ç©æ¸¸æˆï¼Œä½†æ¸¸æˆçš„è§„åˆ™ï¼Œä»æ¥éƒ½æ˜¯æˆ‘å®šçš„ã€‚",
         "æˆ‘ä¸æ˜¯åœ¨æ°”ä½ ä¸åŠªåŠ›ï¼Œæˆ‘æ˜¯åœ¨æ°”ä½ ......è¾œè´Ÿäº†æˆ‘çš„æœŸå¾…ã€‚",
         "ä½ è¿™ä¹ˆæ¸´æœ›æˆ‘çš„å…³æ³¨ï¼Œæ˜¯å—ï¼Ÿå¯ä»¥ã€‚ä»Šå¤©å­¦ä¸å®Œï¼Œä½ å°±åˆ«æƒ³ç¡è§‰äº†ã€‚æˆ‘ä¼šç”¨ä¸€æ•´æ™šçš„æ—¶é—´ï¼Œå¥½å¥½åœ°'å…³æ³¨'ä½ ã€‚",
         "åˆ«ç”¨é‚£ç§çœ¼ç¥çœ‹æˆ‘ã€‚ä½ ä»Šå¤©çš„è¡¨ç°ï¼Œè®©æˆ‘è§‰å¾—æœ‰å¿…è¦......å¯¹ä½ çš„'æ•™è‚²'æ–¹å¼ï¼Œè¿›è¡Œä¸€ç‚¹å°å°çš„è°ƒæ•´äº†ã€‚ä½ ä¼š'å–œæ¬¢'çš„ã€‚",
         "ä½ ä»¥ä¸ºåªæ˜¯åœ¨æµªè´¹ä½ è‡ªå·±çš„æ—¶é—´ï¼Ÿä¸ï¼Œä½ æ˜¯åœ¨æµªè´¹æˆ‘......æŠ•èµ„åœ¨ä½ èº«ä¸Šçš„å¿ƒè¡€ã€‚è¿™ç¬”è´¦ï¼Œä½ è¯´è¯¥æ€ä¹ˆç®—ï¼Ÿ"
             ],
             companion: [
                 "ä½ å†è¿™æ ·ï¼Œæˆ‘å°±......æˆ‘å°±å›å®¶äº†ï¼æ˜å¤©å†æ¥é™ªä½ ï¼",
         "ä½ å†é—¹ï¼Œæˆ‘å°±......æˆ‘å°±äº²ä½ äº†ï¼çœ‹ä½ è¿˜æ•¢ä¸æ•¢åˆ†å¿ƒï¼",
         "å‘€ï¼ä½ ......ä½ åˆ«å¾—å¯¸è¿›å°ºï¼æˆ‘è­¦å‘Šä½ ï¼ï¼ˆä½†æ¯«æ— å¨æ…‘åŠ›ï¼‰",
         "ç®—æˆ‘æ€•äº†ä½ äº†ï¼Œè¡Œä¸è¡Œï¼Ÿæ±‚æ±‚ä½ ï¼Œå…ˆåšå®Œè¿™é¡µé¢˜ï¼Œå°±ä¸€é¡µ......",
         "......å­¦å®Œäº†......å­¦å®Œäº†æˆ‘éšä½ æ€ä¹ˆæ ·ï¼Œå¥½ä¸å¥½ï¼Ÿ"
             ],
             believer: [
                 "å¤Ÿäº†ï¼ä¸å­¦äº†ï¼è¿™ç ´ä¹¦æœ‰ä»€ä¹ˆå¥½å­¦çš„ï¼Ÿ",
         "ï¼ˆä¸€æŠŠåˆä¸Šä½ çš„ä¹¦ï¼Œæ‰”åˆ°ä¸€è¾¹ï¼‰çƒ¦æ­»äº†ï¼ä¸ºäº†è®©ä½ å¼€å¿ƒæ‰é™ªä½ å­¦ï¼Œç°åœ¨ä½ ä¸å¼€å¿ƒäº†ï¼Œè¿˜å­¦ä»€ä¹ˆï¼Ÿ",
         "èµ°ï¼ç°åœ¨å°±èµ°ï¼å¸¦ä½ å»åšç‚¹æ¯”å­¦ä¹ æœ‰æ„ä¹‰ä¸€ç™¾å€çš„äº‹------åˆ·æˆ‘çš„å¡ï¼",
         "ä½ èµ¢äº†ï¼ä½ è¿™ä¸ªå°ç£¨äººç²¾ï¼Œå½»å½»åº•åº•èµ¢äº†ï¼ç°åœ¨è¯´å§ï¼Œæƒ³å»å“ªå„¿ç©ï¼Ÿæœˆçƒéƒ½ç»™ä½ å®‰æ’ï¼",
         "ï¼ˆå’¬ç‰™åˆ‡é½¿ï¼Œä½†å˜´è§’å´åœ¨ä¸Šæ‰¬ï¼‰ä½ å†é—¹ï¼Œæˆ‘å°±ç½šä½ ......ç½šä½ è¿™è¾ˆå­éƒ½åªèƒ½èŠ±æˆ‘çš„é’±ï¼Œåªèƒ½å¾…åœ¨æˆ‘èº«è¾¹ï¼Œå“ªå„¿ä¹Ÿä¸è®¸å»ï¼"
             ]
         }
     },
     // å®Œæˆè¯­åº“
     completion: [
         "æ­å–œå®Œæˆä»»åŠ¡ï¼",
         "å¤ªæ£’äº†ï¼ä½ åšåˆ°äº†ï¼",
         "å®Œç¾å®Œæˆï¼{title}çœŸå‰å®³ï¼",
         "ä»»åŠ¡å®Œæˆï¼ä½ æ˜¯æœ€æ£’çš„ï¼"
     ]
 };
 
 // ä»»åŠ¡ç®¡ç†
 let tasks = [];

 
 // ç»Ÿè®¡æ•°æ®
 let dailyStats = {
     date: getCurrentDateString(),
     gifts: [],
     focusTime: 0,
     completedTasks: 0
 };
 // è¯¦ç»†ç»Ÿè®¡æ•°æ®ç»“æ„
let detailedStats = {
    // æ‰€æœ‰ç•ªèŒ„é’Ÿè®°å½•
    pomodoros: [],
    // ä»»åŠ¡ç»Ÿè®¡
    taskStats: {},
    // æ¯æ—¥ç»Ÿè®¡ç¼“å­˜
    dailyCache: {},
    // æœˆåº¦ç»Ÿè®¡ç¼“å­˜
    monthlyCache: {}
};

// ç•ªèŒ„é’Ÿè®°å½•ç»“æ„
function createPomodoroRecord(duration, status, taskName, statusName) {
    return {
        id: Date.now(),
        date: new Date().toISOString(),
        duration: duration, // ç§’
        status: status, // 'completed', 'abandoned'
        taskName: taskName || 'æœªå‘½åä»»åŠ¡',
        statusName: statusName || 'å­¦ä¹ ',
        timestamp: Date.now()
    };
}

// è®°å½•ç•ªèŒ„é’Ÿå®Œæˆ
function recordPomodoro(duration, taskName, statusName) {
    const record = createPomodoroRecord(duration, 'completed', taskName, statusName);
    
    // æ·»åŠ åˆ°è®°å½•åˆ—è¡¨
    if (!detailedStats.pomodoros) {
        detailedStats.pomodoros = [];
    }
    detailedStats.pomodoros.push(record);
    
    // æ›´æ–°ä»»åŠ¡ç»Ÿè®¡
    if (!detailedStats.taskStats[statusName]) {
        detailedStats.taskStats[statusName] = {
            count: 0,
            totalTime: 0
        };
    }
    detailedStats.taskStats[statusName].count++;
    detailedStats.taskStats[statusName].totalTime += duration;
    
    // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
    saveDetailedStats();
}

// è®°å½•ç•ªèŒ„é’Ÿæ”¾å¼ƒ
function recordAbandonedPomodoro(duration, taskName, statusName) {
    const record = createPomodoroRecord(duration, 'abandoned', taskName, statusName);
    
    if (!detailedStats.pomodoros) {
        detailedStats.pomodoros = [];
    }
    detailedStats.pomodoros.push(record);
    
    saveDetailedStats();
}

// ä¿å­˜è¯¦ç»†ç»Ÿè®¡æ•°æ®
function saveDetailedStats() {
    localStorage.setItem('detailedStats', JSON.stringify(detailedStats));
}

// åŠ è½½è¯¦ç»†ç»Ÿè®¡æ•°æ®
function loadDetailedStats() {
    const saved = localStorage.getItem('detailedStats');
    if (saved) {
        try {
            detailedStats = JSON.parse(saved);
        } catch (e) {
            console.log('Failed to parse detailed stats');
            detailedStats = {
                pomodoros: [],
                taskStats: {},
                dailyCache: {},
                monthlyCache: {}
            };
        }
    }
    // [ä¿®æ”¹] å·²ç§»é™¤æ¼”ç¤ºæ•°æ®ç”Ÿæˆé€»è¾‘
}






 // ä¸“æ³¨è®¡æ—¶ç›¸å…³
 let focusStartTime = null;
 
 // OCæ•°æ®å­˜å‚¨
 let ocData = [
     {
         id: 0,
         name: 'å°è‰¾',
         avatar: 'https://images.unsplash.com/photo-1578662996442-48f60103fc96?w=200&h=200&fit=crop&crop=face',
         userTitle: 'å¤§å°å§',
         customGreeting: '',
         encourageStyles: ['gentle'],
         reminderStyles: ['guardian'],
         customGifts: '',
         selected: true
     }
 ];
 let currentOCIndex = 0;
 let editingOCIndex = -1;
 
 // é£æ ¼ç¼–è¾‘ç›¸å…³
 let currentEditingStyle = '';
 let currentEditingType = '';

 // å·¥å…·å‡½æ•°
 function getCurrentDateString() {
     const now = new Date();
     return `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
 }
 
 function formatTime(seconds) {
     const hours = Math.floor(seconds / 3600);
     const minutes = Math.floor((seconds % 3600) / 60);
     
     if (hours > 0) {
         return `${hours}h ${minutes}m`;
     } else {
         return `${minutes}m`;
     }
 }

 
 
 // OCè¯­ç³»ç»Ÿå‡½æ•°
 let messageChangeTimer = null;
 let lastMessageTime = 0;
 const MESSAGE_COOLDOWN = 1000;
 
 function showOCMessage(message, type = 'encourage', force = false) {
     const messageElement = document.getElementById('ocMessageText');
     if (!messageElement) return;
     
     const now = Date.now();
     if (!force && (now - lastMessageTime) < MESSAGE_COOLDOWN) {
         return;
     }
     
     if (messageChangeTimer) {
         clearTimeout(messageChangeTimer);
         messageChangeTimer = null;
     }
     
     currentMessageType = type;
     lastMessageTime = now;
     
     // è®¾ç½®æ ·å¼ç±»
     messageElement.className = `oc-message-text ${type}`;
     
     // ç»Ÿä¸€ä½¿ç”¨å¹³æ»‘çš„æ·¡å‡ºæ·¡å…¥æ•ˆæœ
     messageElement.classList.add('fade-out');
     setTimeout(() => {
         // ä½¿ç”¨wrapperæ¥ä¼˜åŒ–æ–‡å­—å±…ä¸­
         messageElement.innerHTML = `<span class="oc-message-text-wrapper">${message}</span>`;
         messageElement.classList.remove('fade-out');
     }, 300);
 }
 
 function getInitialMessage() {
     const currentOC = ocData[currentOCIndex];
     const userTitle = currentOC.userTitle || 'å¤§å°å§';
     return `å¿«å¼€å§‹å­¦ä¹ å§ï¼æˆ‘ä¼šä¸€ç›´é™ªç€ä½ ï¼ï¼`.replace(/\{title\}/g, userTitle);
 }
// ä¸“æ³¨é¡µç£ä¿ƒè¯­è°ƒå–å‡½æ•° 
 function getRandomOCMessage(messageType, level = 'normal') {
     const currentOC = ocData[currentOCIndex];
     const userTitle = currentOC.userTitle || 'å¤§å°å§';
     
     let messagePool = [];
     
     if (messageType === 'encourage') {
         const selectedStyles = currentOC.encourageStyles || ['gentle'];
         selectedStyles.forEach(style => {
             // æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå®šä¹‰é£æ ¼
             if (style.startsWith('custom-') && customStyles.encourage[style]) {
                 messagePool = messagePool.concat(customStyles.encourage[style]);
             } else if (ocMessageLibrary.encourage[style]) {
                 // æ£€æŸ¥æ˜¯å¦æœ‰ä¿®æ”¹ç‰ˆæœ¬
                 const modifiedKey = `modified-${style}`;
                 if (customStyles.encourage[modifiedKey]) {
                     messagePool = messagePool.concat(customStyles.encourage[modifiedKey]);
                 } else {
                     messagePool = messagePool.concat(ocMessageLibrary.encourage[style]);
                 }
             }
         });
     } else if (messageType === 'rest') {
         messagePool = ocMessageLibrary.rest;
     } else if (messageType === 'remind') {
         const selectedStyles = currentOC.reminderStyles || ['guardian'];
         selectedStyles.forEach(style => {
             // æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå®šä¹‰é£æ ¼
             if (style.startsWith('custom-') && customStyles.remind[style] && customStyles.remind[style][level]) {
                 messagePool = messagePool.concat(customStyles.remind[style][level]);
             } else if (ocMessageLibrary.remind[level] && ocMessageLibrary.remind[level][style]) {
                 // æ£€æŸ¥æ˜¯å¦æœ‰ä¿®æ”¹ç‰ˆæœ¬
                 const modifiedKey = `modified-${style}`;
                 if (customStyles.remind[modifiedKey] && customStyles.remind[modifiedKey][level]) {
                     messagePool = messagePool.concat(customStyles.remind[modifiedKey][level]);
                 } else {
                     messagePool = messagePool.concat(ocMessageLibrary.remind[level][style]);
                 }
             }
         });
     } else if (messageType === 'completion') {
         messagePool = ocMessageLibrary.completion;
     }
     
     // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„æ¶ˆæ¯ï¼Œä½¿ç”¨é»˜è®¤æ¶ˆæ¯
     if (messagePool.length === 0) {
         if (messageType === 'encourage') {
             messagePool = ocMessageLibrary.encourage.gentle;
         } else if (messageType === 'rest') {
             messagePool = ocMessageLibrary.rest;
         } else if (messageType === 'remind') {
             messagePool = ocMessageLibrary.remind[level].gentle || ['å¿«å›æ¥å­¦ä¹ å§ï¼'];
         } else if (messageType === 'completion') {
             messagePool = ocMessageLibrary.completion;
         }
     }
     
     // éšæœºé€‰æ‹©ä¸€æ¡æ¶ˆæ¯
     const selectedMessage = messagePool[Math.floor(Math.random() * messagePool.length)];
     
     // æ›¿æ¢å ä½ç¬¦
     return selectedMessage.replace(/\{title\}/g, userTitle);
 }
 
 function getRandomMessage(messageArray) {
     return messageArray[Math.floor(Math.random() * messageArray.length)];
 }
 
 function startEncourageLoop() {
     if (encourageInterval) {
         clearInterval(encourageInterval);
     }
     
     setTimeout(() => {
         if (isTimerRunning && !isPaused && !isIgnoring) {
             const message = getRandomOCMessage('encourage');
             showOCMessage(message, 'encourage', true);
         }
     }, 1000);
     
     encourageInterval = setInterval(() => {
         if (isTimerRunning && !isPaused && currentMessageType === 'encourage' && !isIgnoring) {
             const message = getRandomOCMessage('encourage');
             showOCMessage(message, 'encourage', true);
         }
     }, 45000);
 }
 
 function stopEncourageLoop() {
     if (encourageInterval) {
         clearInterval(encourageInterval);
         encourageInterval = null;
     }
 }
 
 function showRestMessage() {
     if (isIgnoring) return;
     const message = getRandomOCMessage('rest');
     showOCMessage(message, 'rest', true);
 }
 
 function showRemindMessage(level = 'normal') {
     if (isIgnoring) return;
     
     const message = getRandomOCMessage('remind', level);
     const messageType = level === 'normal' ? 'remind-normal' : 
                       level === 'annoyed' ? 'remind-annoyed' : 'remind-angry';
     showOCMessage(message, messageType, true);
     
     if (messageChangeTimer) {
         clearTimeout(messageChangeTimer);
     }
     
     messageChangeTimer = setTimeout(() => {
         if (currentMessageType.startsWith('remind') && !isIgnoring) {
             if (isTimerRunning && !isPaused) {
                 const encourageMessage = getRandomOCMessage('encourage');
                 showOCMessage(encourageMessage, 'encourage', true);
             } else if (!isTimerRunning) {
                 showOCMessage(getInitialMessage(), 'initial', true);
             }
         }
     }, 5000);
 }

 // OCäº¤äº’ç³»ç»Ÿ
 function handleOCClick() {
     if (!canInteract || isIgnoring) return;
     
     clickCount++;
     
     if (clickTimer) {
         clearTimeout(clickTimer);
     }
     
     clickTimer = setTimeout(() => {
         if (clickCount < 6) {
             clickCount = 0;
         }
     }, 3000);
     
     let level = 'normal';
     if (clickCount >= 5) {
         level = 'angry';
         const ocAvatar = document.querySelector('.oc-avatar');
         ocAvatar.classList.add('angry-shake');
         setTimeout(() => {
             ocAvatar.classList.remove('angry-shake');
         }, 600);
         
         if (clickCount >= 6) {
             enterIgnoreState();
         }
     } else if (clickCount >= 3) {
         level = 'annoyed';
     }
     
     showRemindMessage(level);
 }
 
 function enterIgnoreState() {
     isIgnoring = true;
     canInteract = false;
     
     if (messageChangeTimer) {
         clearTimeout(messageChangeTimer);
         messageChangeTimer = null;
     }
     
     messageChangeTimer = setTimeout(() => {
         showOCMessage('o(Â´^ï½€)oä¸ç†ä½ äº†ï¼ï¼', 'ignore', true);
         
         if (ignoreTimer) {
             clearTimeout(ignoreTimer);
         }
         ignoreTimer = setTimeout(() => {
             exitIgnoreState();
         }, 30000);
     }, 5000);
 }
 
 function exitIgnoreState() {
     isIgnoring = false;
     canInteract = true;
     clickCount = 0;
     
     if (messageChangeTimer) {
         clearTimeout(messageChangeTimer);
         messageChangeTimer = null;
     }
     
     setTimeout(() => {
         if (isTimerRunning && !isPaused) {
             const encourageMessage = getRandomOCMessage('encourage');
             showOCMessage(encourageMessage, 'encourage', true);
         } else {
             showOCMessage(getInitialMessage(), 'initial', true);
         }
     }, 500);
 }
 
 function resetOCInteraction() {
     clickCount = 0;
     canInteract = true;
     isIgnoring = false;
     
     if (clickTimer) {
         clearTimeout(clickTimer);
         clickTimer = null;
     }
     if (recoveryTimer) {
         clearTimeout(recoveryTimer);
         recoveryTimer = null;
     }
     if (ignoreTimer) {
         clearTimeout(ignoreTimer);
         ignoreTimer = null;
     }
 }

 // é£æ ¼ç¼–è¾‘ç›¸å…³å‡½æ•° - ä¼˜åŒ–é€»è¾‘
 function handleStyleClick(event, style, type) {
     event.stopPropagation();
     
     // å¦‚æœç‚¹å‡»çš„æ˜¯åœ†åœˆåŒºåŸŸï¼Œåˆ™ä¸è§¦å‘ç¼–è¾‘
     if (event.target.classList.contains('style-selector-circle') || 
         event.target.classList.contains('custom-style-delete')) {
         return;
     }
     
     // æ˜¾ç¤ºé£æ ¼ç¼–è¾‘å¼¹çª—
     showStyleEditor(style, type);
 }
 
 function handleStyleSelect(event, style) {
     event.stopPropagation();
     const styleOption = event.target.closest('.style-option');
     if (styleOption) {
         styleOption.classList.toggle('selected');
     }
 }
 
 // ä¼˜åŒ–çš„è‡ªå®šä¹‰é£æ ¼åˆ›å»ºé€»è¾‘
 function handleCustomStyleClick(type) {
     // å¼¹å‡ºè¾“å…¥æ¡†è®©ç”¨æˆ·è¾“å…¥é£æ ¼åç§°
     const styleTitle = prompt('è¯·è¾“å…¥è‡ªå®šä¹‰é£æ ¼åç§°ï¼ˆå»ºè®®4-8ä¸ªå­—ç¬¦ï¼‰ï¼š');
     
     if (!styleTitle || !styleTitle.trim()) {
         return;
     }
     
     const trimmedTitle = styleTitle.trim();
     if (trimmedTitle.length > 12) {
         alert('é£æ ¼åç§°ä¸èƒ½è¶…è¿‡12ä¸ªå­—ç¬¦');
         return;
     }
     
     // ç”Ÿæˆå”¯ä¸€çš„è‡ªå®šä¹‰é£æ ¼ID
     const customStyleId = `custom-${type}-${Date.now()}`;
     
     // åˆå§‹åŒ–è‡ªå®šä¹‰é£æ ¼æ•°æ®
     if (type === 'encourage') {
         customStyles.encourage[customStyleId] = ['åœ¨è¿™é‡Œè¾“å…¥é¼“åŠ±è¯­å¥ï¼Œæ¯è¡Œä¸€æ¡...'];
     } else {
         customStyles.remind[customStyleId] = {
             normal: ['åœ¨è¿™é‡Œè¾“å…¥æ­£å¸¸æé†’è¯­å¥...'],
             annoyed: ['åœ¨è¿™é‡Œè¾“å…¥çƒ¦æ¼æé†’è¯­å¥...'],
             angry: ['åœ¨è¿™é‡Œè¾“å…¥ç”Ÿæ°”æé†’è¯­å¥...']
         };
     }
     
     // ä¿å­˜é£æ ¼å…ƒæ•°æ®
     if (!customStyles.metadata) {
         customStyles.metadata = {};
     }
     customStyles.metadata[customStyleId] = {
         title: trimmedTitle,
         type: type,
         desc: 'ç‚¹å‡»ç¼–è¾‘æ¥è‡ªå®šä¹‰è¯­å¥å†…å®¹'
     };
     
     // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
     saveCustomStyles();
     
     // é‡æ–°æ¸²æŸ“é£æ ¼é€‰æ‹©åŒºåŸŸä»¥æ˜¾ç¤ºæ–°åˆ›å»ºçš„é£æ ¼
     renderCustomStylesInGrid(type);
     
     // è‡ªåŠ¨æ‰“å¼€ç¼–è¾‘å™¨è®©ç”¨æˆ·ç¼–è¾‘è¯­å¥
     setTimeout(() => {
         showStyleEditor(customStyleId, type, trimmedTitle);
     }, 100);
 }
 
 // æ¸²æŸ“è‡ªå®šä¹‰é£æ ¼åˆ°å¯¹åº”çš„ç½‘æ ¼ä¸­
 function renderCustomStylesInGrid(type) {
     const gridId = type === 'encourage' ? 'encourageStyleGrid' : 'reminderStyleGrid';
     const grid = document.getElementById(gridId);
     if (!grid) return;
     
     // ç§»é™¤æ—§çš„è‡ªå®šä¹‰é£æ ¼å¡ç‰‡ï¼ˆä¿ç•™é¢„è®¾é£æ ¼å’Œ"è‡ªå®šä¹‰"æŒ‰é’®ï¼‰
     const customCards = grid.querySelectorAll('.style-option[data-style^="custom-"]:not([data-style="custom-encourage"]):not([data-style="custom-remind"])');
     customCards.forEach(card => card.remove());
     
     // è·å–å¯¹åº”ç±»å‹çš„è‡ªå®šä¹‰é£æ ¼
     const customStylesOfType = Object.keys(customStyles.metadata || {})
         .filter(styleId => customStyles.metadata[styleId].type === type);
     
     // ä¸ºæ¯ä¸ªè‡ªå®šä¹‰é£æ ¼åˆ›å»ºå¡ç‰‡
     customStylesOfType.forEach(styleId => {
         const metadata = customStyles.metadata[styleId];
         const styleCard = createCustomStyleCard(styleId, metadata);
         
         // æ’å…¥åˆ°"è‡ªå®šä¹‰"æŒ‰é’®ä¹‹å‰
         const customButton = grid.querySelector('[data-style="custom-' + type + '"]');
         if (customButton) {
             grid.insertBefore(styleCard, customButton);
         }
     });
 }
 
 // åˆ›å»ºè‡ªå®šä¹‰é£æ ¼å¡ç‰‡
 function createCustomStyleCard(styleId, metadata) {
     const styleCard = document.createElement('div');
     styleCard.className = 'style-option';
     styleCard.setAttribute('data-style', styleId);
     styleCard.onclick = (event) => handleStyleClick(event, styleId, metadata.type);
     
     styleCard.innerHTML = `
         <div class="style-title">${metadata.title}</div>
         <div class="style-desc">${metadata.desc}</div>
         <div class="style-selector-circle" onclick="event.stopPropagation(); handleStyleSelect(event, '${styleId}')"></div>
         <button class="custom-style-delete" onclick="event.stopPropagation(); deleteCustomStyle('${styleId}', '${metadata.type}')" title="åˆ é™¤æ­¤è‡ªå®šä¹‰é£æ ¼">
             <svg class="w-3 h-3 text-red-500" fill="currentColor" viewBox="0 0 24 24">
                 <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
             </svg>
         </button>
     `;
     
     return styleCard;
 }
 
 // åˆ é™¤è‡ªå®šä¹‰é£æ ¼
 function deleteCustomStyle(styleId, type) {
     if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè‡ªå®šä¹‰é£æ ¼å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) {
         // ä»å­˜å‚¨ä¸­åˆ é™¤
         if (customStyles.encourage && customStyles.encourage[styleId]) {
             delete customStyles.encourage[styleId];
         }
         if (customStyles.remind && customStyles.remind[styleId]) {
             delete customStyles.remind[styleId];
         }
         if (customStyles.metadata && customStyles.metadata[styleId]) {
             delete customStyles.metadata[styleId];
         }
         
         // ä»å½“å‰ç¼–è¾‘çš„OCä¸­ç§»é™¤è¯¥é£æ ¼
         const currentOC = ocData[editingOCIndex >= 0 ? editingOCIndex : currentOCIndex];
         if (currentOC) {
             if (type === 'encourage' && currentOC.encourageStyles) {
                 currentOC.encourageStyles = currentOC.encourageStyles.filter(s => s !== styleId);
             } else if (type === 'remind' && currentOC.reminderStyles) {
                 currentOC.reminderStyles = currentOC.reminderStyles.filter(s => s !== styleId);
             }
         }
         
         // ä¿å­˜æ›´æ”¹
         saveCustomStyles();
         
         // é‡æ–°æ¸²æŸ“
         renderCustomStylesInGrid(type);
         
         // å¦‚æœå½“å‰æ­£åœ¨ç¼–è¾‘è¿™ä¸ªé£æ ¼ï¼Œå…³é—­ç¼–è¾‘å™¨
         if (currentEditingStyle === styleId) {
             closeStyleEditor();
         }
     }
 }
 
 function showStyleEditor(style, type, customTitle = '') {
     currentEditingStyle = style;
     currentEditingType = type;
     
     const modal = document.getElementById('styleEditorModal');
     const title = document.getElementById('styleEditorTitle');
     const desc = document.getElementById('styleEditorDesc');
     const textarea = document.getElementById('styleEditorTextarea');
     
     // è®¾ç½®æ ‡é¢˜
     let styleTitle = customTitle || getStyleTitle(style);
     title.textContent = `ç¼–è¾‘${styleTitle}è¯­å¥`;
     
     // è®¾ç½®æè¿°
     if (type === 'encourage') {
         desc.textContent = 'æ¯è¡Œä¸€æ¡é¼“åŠ±è¯­å¥ï¼Œ{title} ä¼šè¢«æ›¿æ¢ä¸ºç”¨æˆ·ç§°å‘¼';
     } else {
         desc.textContent = 'æ¯è¡Œä¸€æ¡ç£ä¿ƒè¯­å¥ï¼Œåˆ†ä¸ºä¸‰ä¸ªçº§åˆ«ï¼šæ­£å¸¸/çƒ¦æ¼/ç”Ÿæ°”';
     }
     
     // åŠ è½½å½“å‰è¯­å¥
     let messages = [];
     if (type === 'encourage') {
         if (style.startsWith('custom-') && customStyles.encourage[style]) {
             messages = [...customStyles.encourage[style]];
         } else if (ocMessageLibrary.encourage[style]) {
             // æ£€æŸ¥æ˜¯å¦æœ‰è‡ªå®šä¹‰ä¿®æ”¹çš„ç‰ˆæœ¬
             const modifiedKey = `modified-${style}`;
             if (customStyles.encourage[modifiedKey]) {
                 messages = [...customStyles.encourage[modifiedKey]];
             } else {
                 messages = [...ocMessageLibrary.encourage[style]];
             }
         }
     } else {
         if (style.startsWith('custom-') && customStyles.remind[style]) {
             // è‡ªå®šä¹‰ç£ä¿ƒé£æ ¼ï¼Œæ˜¾ç¤ºæ‰€æœ‰çº§åˆ«
             messages = [
                 '=== æ­£å¸¸æé†’ ===',
                 ...customStyles.remind[style].normal,
                 '',
                 '=== çƒ¦æ¼æé†’ ===',
                 ...customStyles.remind[style].annoyed,
                 '',
                 '=== ç”Ÿæ°”æé†’ ===',
                 ...customStyles.remind[style].angry
             ];
         } else if (ocMessageLibrary.remind.normal[style]) {
             // æ£€æŸ¥æ˜¯å¦æœ‰è‡ªå®šä¹‰ä¿®æ”¹çš„ç‰ˆæœ¬
             const modifiedKey = `modified-${style}`;
             if (customStyles.remind[modifiedKey]) {
                 messages = [
                     '=== æ­£å¸¸æé†’ ===',
                     ...customStyles.remind[modifiedKey].normal,
                     '',
                     '=== çƒ¦æ¼æé†’ ===',
                     ...customStyles.remind[modifiedKey].annoyed,
                     '',
                     '=== ç”Ÿæ°”æé†’ ===',
                     ...customStyles.remind[modifiedKey].angry
                 ];
             } else {
                 // é¢„è®¾ç£ä¿ƒé£æ ¼ï¼Œæ˜¾ç¤ºæ‰€æœ‰çº§åˆ«
                 messages = [
                     '=== æ­£å¸¸æé†’ ===',
                     ...ocMessageLibrary.remind.normal[style],
                     '',
                     '=== çƒ¦æ¼æé†’ ===',
                     ...ocMessageLibrary.remind.annoyed[style],
                     '',
                     '=== ç”Ÿæ°”æé†’ ===',
                     ...ocMessageLibrary.remind.angry[style]
                 ];
             }
         }
     }
     
     textarea.value = messages.join('\n');
     modal.classList.add('show');
 }
 
 function getStyleTitle(style) {
     // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå®šä¹‰é£æ ¼
     if (customStyles.metadata && customStyles.metadata[style]) {
         return customStyles.metadata[style].title;
     }
     
     // é¢„è®¾é£æ ¼æ ‡é¢˜
     const styleTitles = {
         gentle: 'æ¸©æŸ”å®ˆæŠ¤å‹',
         tsundere: 'å‚²å¨‡æ¯’èˆŒå‹',
         cheerful: 'é˜³å…‰å¼€æœ—å‹',
         aloof: 'æ·¡æ¼ æ·±æ²‰å‹',
         mature: 'æˆç†ŸåŒ…å®¹å‹',
         cunning: 'è…¹é»‘å¿ƒæœºå‹',
         shy: 'çº¯æƒ…å®³ç¾å‹',
         doting: 'æ— è„‘æººçˆ±å‹',
         guardian: 'å®ˆæŠ¤è€…',
         pusher: 'é­ç­–è€…',
         cheerleader: 'åº”æ´è€…',
         observer: 'è§‚å¯Ÿè€…',
         guide: 'å¼•å¯¼è€…',
         strategist: 'å¸ƒå±€è€…',
         companion: 'é™ªä¼´è€…',
         believer: 'æººçˆ±è€…'
     };
     
     return styleTitles[style] || 'è‡ªå®šä¹‰é£æ ¼';
 }
 
 function closeStyleEditor() {
     document.getElementById('styleEditorModal').classList.remove('show');
 }
 
 function saveStyleMessages() {
     const textarea = document.getElementById('styleEditorTextarea');
     const messages = textarea.value.trim().split('\n').filter(line => line.trim());
     
     if (currentEditingType === 'encourage') {
         // ä¿å­˜é¼“åŠ±è¯­å¥
         if (currentEditingStyle.startsWith('custom-')) {
             // è‡ªå®šä¹‰é£æ ¼ç›´æ¥ä¿å­˜
             customStyles.encourage[currentEditingStyle] = messages;
         } else {
             // é¢„è®¾é£æ ¼ä¿å­˜ä¸ºä¿®æ”¹ç‰ˆæœ¬
             const modifiedKey = `modified-${currentEditingStyle}`;
             customStyles.encourage[modifiedKey] = messages;
         }
     } else {
         // ä¿å­˜ç£ä¿ƒè¯­å¥
         const normalMessages = [];
         const annoyedMessages = [];
         const angryMessages = [];
         
         let currentLevel = 'normal';
         messages.forEach(line => {
             if (line.includes('=== æ­£å¸¸æé†’ ===')) {
                 currentLevel = 'normal';
             } else if (line.includes('=== çƒ¦æ¼æé†’ ===')) {
                 currentLevel = 'annoyed';
             } else if (line.includes('=== ç”Ÿæ°”æé†’ ===')) {
                 currentLevel = 'angry';
             } else if (line.trim()) {
                 if (currentLevel === 'normal') {
                     normalMessages.push(line);
                 } else if (currentLevel === 'annoyed') {
                     annoyedMessages.push(line);
                 } else {
                     angryMessages.push(line);
                 }
             }
         });
         
         if (currentEditingStyle.startsWith('custom-')) {
             // è‡ªå®šä¹‰é£æ ¼ç›´æ¥ä¿å­˜
             customStyles.remind[currentEditingStyle] = {
                 normal: normalMessages,
                 annoyed: annoyedMessages,
                 angry: angryMessages
             };
         } else {
             // é¢„è®¾é£æ ¼ä¿å­˜ä¸ºä¿®æ”¹ç‰ˆæœ¬
             const modifiedKey = `modified-${currentEditingStyle}`;
             customStyles.remind[modifiedKey] = {
                 normal: normalMessages,
                 annoyed: annoyedMessages,
                 angry: angryMessages
             };
         }
     }
     
     saveCustomStyles();
     closeStyleEditor();
     alert('è¯­å¥å·²ä¿å­˜ï¼ä¿®æ”¹å°†åœ¨ä¸“æ³¨é¡µé¢ç”Ÿæ•ˆã€‚');
 }
 
 function saveCustomStyles() {
     localStorage.setItem('customStyles', JSON.stringify(customStyles));
 }
 
 function loadCustomStyles() {
     const saved = localStorage.getItem('customStyles');
     if (saved) {
         try {
             const loaded = JSON.parse(saved);
             customStyles = {
                 encourage: loaded.encourage || {},
                 remind: loaded.remind || {},
                 metadata: loaded.metadata || {}
             };
         } catch (e) {
             console.log('Failed to parse custom styles');
         }
     }
 }

 // ç»Ÿè®¡æ•°æ®ç®¡ç†
 function loadDailyStats() {
     const today = getCurrentDateString();
     const savedStats = localStorage.getItem('dailyStats_' + today);
     
     if (savedStats) {
         try {
             dailyStats = JSON.parse(savedStats);
         } catch (e) {
             console.log('Failed to parse daily stats');
             dailyStats = {
                 date: today,
                 gifts: [],
                 focusTime: 0,
                 completedTasks: 0
             };
         }
     } else {
         dailyStats = {
             date: today,
             gifts: [],
             focusTime: 0,
             completedTasks: 0
         };
     }
     
     updateStatsDisplay();
 }
 
 function saveDailyStats() {
     localStorage.setItem('dailyStats_' + dailyStats.date, JSON.stringify(dailyStats));
 }
 
 function updateStatsDisplay() {
     document.getElementById('todayGifts').textContent = dailyStats.gifts.length;
     document.getElementById('focusTime').textContent = formatTime(dailyStats.focusTime);
     document.getElementById('todayCompleted').textContent = dailyStats.completedTasks;
 }
 
 function addGift(giftText, senderOCIndex) {
     const now = new Date();
     const senderOC = ocData[senderOCIndex] || ocData[0];
     const gift = {
         text: giftText,
         time: now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }),
         timestamp: now.getTime(),
         senderName: senderOC.name,
         senderIndex: senderOCIndex
     };
     
     dailyStats.gifts.push(gift);
     saveDailyStats();
     updateStatsDisplay();
 }
 
 function addFocusTime(seconds) {
     dailyStats.focusTime += seconds;
     saveDailyStats();
     updateStatsDisplay();
 }
 
 function incrementCompletedTasks() {
     dailyStats.completedTasks++;
     saveDailyStats();
     updateStatsDisplay();
 }
 
 // ç¤¼ç‰©å¼¹çª—
 function showGiftModal() {
     const modal = document.getElementById('giftModal');
     const giftList = document.getElementById('giftList');
     
     if (dailyStats.gifts.length === 0) {
         giftList.innerHTML = `
             <div class="text-center text-slate-500 py-8">
                 <div class="text-4xl mb-2">ğŸ</div>
                 <p>ä»Šå¤©è¿˜æ²¡æœ‰æ”¶åˆ°ç¤¼ç‰©å‘¢ï½<br>å®Œæˆç•ªèŒ„é’Ÿå°±èƒ½è·å¾—OCçš„ç¤¼ç‰©å¥–åŠ±ï¼</p>
             </div>
         `;
     } else {
         giftList.innerHTML = dailyStats.gifts.map(gift => `
             <div class="gift-item">
                 <div class="flex-1">
                     <div class="text-sm text-slate-700 mb-1">${gift.text}</div>
                     <div class="gift-sender">æ¥è‡ª ${gift.senderName}</div>
                 </div>
                 <div class="gift-time">${gift.time}</div>
             </div>
         `).join('');
     }
     
     modal.classList.add('show');
 }
 
 function closeGiftModal() {
     document.getElementById('giftModal').classList.remove('show');
 }
 
 // å·²å®Œæˆä»»åŠ¡å¼¹çª—
 function showCompletedTasksModal() {
     const modal = document.getElementById('completedTasksModal');
     const completedTasksList = document.getElementById('completedTasksList');
     
     const completedTasks = tasks.filter(task => task.status === 'completed');
     
     if (completedTasks.length === 0) {
         completedTasksList.innerHTML = `
             <div class="text-center text-slate-500 py-8">
                 <div class="text-4xl mb-2">ğŸ“</div>
                 <p>ä»Šå¤©è¿˜æ²¡æœ‰å®Œæˆä»»ä½•ä»»åŠ¡å‘¢ï½<br>å¿«å»å®Œæˆä¸€äº›ä»»åŠ¡å§ï¼</p>
             </div>
         `;
     } else {
         completedTasksList.innerHTML = completedTasks.map(task => `
             <div class="completed-task-item">
                 <div class="w-5 h-5 bg-slate-400 rounded-full flex items-center justify-center flex-shrink-0">
                     <svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 24 24">
                         <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
                     </svg>
                 </div>
                 <div class="completed-task-title">${task.title}</div>
                 <button class="undo-btn" onclick="undoTaskCompletion(${task.id})">æ’¤é”€</button>
             </div>
         `).join('');
     }
     
     modal.classList.add('show');
 }
 
 function closeCompletedTasksModal() {
     document.getElementById('completedTasksModal').classList.remove('show');
 }
 
 function undoTaskCompletion(taskId) {
     const task = tasks.find(t => t.id === taskId);
     if (task) {
         task.status = 'pending';
         if (dailyStats.completedTasks > 0) {
             dailyStats.completedTasks--;
             saveDailyStats();
             updateStatsDisplay();
         }
         saveTasks();
         renderTasks();
         showCompletedTasksModal();
     }
 }

 // ä»»åŠ¡ç®¡ç†å‡½æ•°
 function renderTasks() {
     const taskList = document.getElementById('taskList');
     if (!taskList) return;
     
     const uncompletedTasks = tasks.filter(task => task.status !== 'completed');
     
     taskList.innerHTML = '';
     
     uncompletedTasks.forEach((task, index) => {
         const taskItem = document.createElement('div');
         const displayStatus = 'in-progress';
         taskItem.className = `task-item ${displayStatus}`;
         taskItem.dataset.taskId = task.id;
         
         taskItem.innerHTML = `
             <div class="flex items-center">
                 <div class="task-checkbox ${displayStatus}" onclick="toggleTaskStatus(${task.id})">
                 </div>
                 <div class="task-title">${task.title}</div>
                 <div class="task-actions">
                     <div class="task-action-btn task-edit-btn" onclick="event.stopPropagation(); editTask(${task.id})">
                         <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 24 24">
                             <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                         </svg>
                     </div>
                     <div class="task-action-btn task-delete-btn" onclick="event.stopPropagation(); deleteTask(${task.id})">
                         <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 24 24">
                             <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                         </svg>
                     </div>
                 </div>
             </div>
         `;
         
         taskList.appendChild(taskItem);
     });
     
     updateTaskProgress();
     updateTaskSelector();
 }
 
 function editTask(taskId) {
     const task = tasks.find(t => t.id === taskId);
     if (!task) return;
     
     const newTitle = prompt('ç¼–è¾‘ä»»åŠ¡å†…å®¹ï¼š', task.title);
     if (newTitle && newTitle.trim() && newTitle.trim() !== task.title) {
         task.title = newTitle.trim();
         saveTasks();
         renderTasks();
     }
 }
 
 function deleteTask(taskId) {
     tasks = tasks.filter(t => t.id !== taskId);
     saveTasks();
     renderTasks();
 }
 
 function updateTaskSelector() {
     const taskSelector = document.getElementById('taskSelector');
     if (!taskSelector) return;
     
     taskSelector.innerHTML = '';
     
     const uncompletedTasks = tasks.filter(task => task.status !== 'completed');
     
     uncompletedTasks.forEach(task => {
         const taskOption = document.createElement('div');
         taskOption.className = 'task-option';
         const displayStatus = 'in-progress';
         taskOption.onclick = () => selectTask(task.title, getTaskStatusText(displayStatus), getTaskStatusColor(displayStatus));
         
         taskOption.innerHTML = `
             <div class="flex items-center justify-between w-full">
                 <span>${task.title}</span>
                 <div class="w-4 h-4 border-2 border-blue-400 rounded-full flex items-center justify-center">
                 </div>
             </div>
         `;
         
         taskSelector.appendChild(taskOption);
     });
 }
 
 function getTaskStatusText(status) {
     switch(status) {
         case 'completed': return 'å·²å®Œæˆ';
         case 'in-progress': return 'è¿›è¡Œä¸­';
         case 'pending': return 'å¾…å¼€å§‹';
         default: return 'è¿›è¡Œä¸­';
     }
 }
 
 function getTaskStatusColor(status) {
     switch(status) {
         case 'completed': return 'slate';
         case 'in-progress': return 'blue';
         case 'pending': return 'blue';
         default: return 'blue';
     }
 }
 
 function addNewTask() {
     const taskList = document.getElementById('taskList');
     
     const inputContainer = document.createElement('div');
     inputContainer.className = 'mb-2';
     
     const input = document.createElement('input');
     input.type = 'text';
     input.className = 'add-task-input';
     input.placeholder = 'è¾“å…¥æ–°ä»»åŠ¡å†…å®¹...';
     input.autofocus = true;
     
     const handleAddTask = () => {
         const title = input.value.trim();
         if (title) {
             const newTask = {
                 id: Date.now(),
                 title: title,
                 status: 'pending'
             };
             tasks.push(newTask);
             saveTasks();
             renderTasks();
         } else {
             inputContainer.remove();
         }
     };
     
     input.addEventListener('keypress', (e) => {
         if (e.key === 'Enter') {
             handleAddTask();
         }
     });
     
     input.addEventListener('blur', handleAddTask);
     
     inputContainer.appendChild(input);
     taskList.insertBefore(inputContainer, taskList.firstChild);
 }
 
 function toggleTaskStatus(taskId) {
     const task = tasks.find(t => t.id === taskId);
     if (!task) return;
     
     const wasCompleted = task.status === 'completed';
     
     if (task.status === 'completed') {
         task.status = 'pending';
     } else {
         task.status = 'completed';
         if (!wasCompleted) {
             incrementCompletedTasks();
         }
     }
     
     saveTasks();
     renderTasks();
 }
 
 function updateTaskProgress() {
     const completed = tasks.filter(t => t.status === 'completed').length;
     const uncompleted = tasks.filter(t => t.status !== 'completed').length;
     const progressElement = document.getElementById('taskProgress');
     if (progressElement) {
         progressElement.textContent = `${completed}/${completed + uncompleted} å®Œæˆ`;
     }
 }
 
 function saveTasks() {
     localStorage.setItem('tasks', JSON.stringify(tasks));
 }
 
 function loadTasks() {
     const savedTasks = localStorage.getItem('tasks');
     if (savedTasks) {
         try {
             tasks = JSON.parse(savedTasks);
         } catch (e) {
             console.log('Failed to parse saved tasks');
         }
     }
 }

 // é¡µé¢åˆ‡æ¢å‡½æ•°
 function showPage(pageId) {
     const pages = document.querySelectorAll('.page');
     pages.forEach(page => {
         if (page.id === pageId) {
             page.classList.remove('hidden');
             page.classList.add('show');
         } else {
             page.classList.add('hidden');
             page.classList.remove('show');
         }
     });
     currentPage = pageId.replace('Page', '');
     
     if (pageId === 'homePage') {
         setTimeout(renderTasks, 100);
     }
 }

 function goToFocus() {
showPage('focusPage');
isStatusSelected = false;
currentStatus = { name: '', icon: 'âšª' };
resetOCInteraction();

setTimeout(() => {
 // ä½¿ç”¨ä¼˜åŒ–çš„çŠ¶æ€æ–‡å­—è®¾ç½®
 const statusButton = document.getElementById('statusButton');
 statusButton.innerHTML = '<span class="oc-status-pure-text">çŠ¶æ€å¾…é€‰æ‹©</span> <span class="oc-status-emoji">âšª</span>';
 
 const startBtnHint = document.getElementById('startBtnHint');
 startBtnHint.classList.add('hidden');
 
 stopHeartbeatAnimation();
 document.querySelectorAll('.status-option').forEach(option => {
     option.classList.remove('active');
 });
 
 // åˆå§‹åŒ–è‡ªå®šä¹‰çŠ¶æ€åˆ°ä¸“æ³¨é¡µ
 initCustomStatusInFocusPage();
}, 100);
}



 function goToOCCards() {
     showPage('ocCardsPage');
     renderOCCards();
 }
// è·³è½¬åˆ°æ•°æ®ä¸­å¿ƒé¡µé¢
function goToDataCenter() {
    showPage('dataCenterPage');
    loadDataCenterContent();
}

// ä»æ•°æ®ä¸­å¿ƒè¿”å›é¦–é¡µ
function goBackFromDataCenter() {
    showPage('homePage');
}

// åŠ è½½æ•°æ®ä¸­å¿ƒå†…å®¹
function loadDataCenterContent() {
    const contentContainer = document.getElementById('dataCenterContent');
    
    contentContainer.innerHTML = `
        <div class="relative z-10 min-h-screen flex flex-col">
            <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
            <div class="flex items-center justify-between p-4">
                <button onclick="goBackFromDataCenter()" class="glass-card rounded-full p-3 transition-all hover:scale-105">
                    <svg class="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                    </svg>
                </button>
                <h1 class="text-xl font-bold text-purple-500">ä¸“æ³¨æ•°æ®ä¸­å¿ƒ</h1>
                <button class="glass-card rounded-full p-3 transition-all hover:scale-105">
                    <svg class="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                    </svg>
                </button>
            </div>

            <!-- OCçš„è¯ -->
            <div class="px-4 mb-4">
                <div class="flex items-start gap-3">
                    <div class="oc-avatar-small flex-shrink-0">OC</div>
                    <div class="oc-bubble flex-1 p-4">
                        <p id="ocDataMessage" class="text-sm text-gray-700 leading-relaxed"></p>
                    </div>
                </div>
            </div>

            <!-- ç»Ÿè®¡æ±‡æ€»å¡ç‰‡ -->
            <div class="px-4 mb-6">
                <div class="glass-card rounded-2xl p-5">
                    <div class="grid grid-cols-2 gap-4">
                        <div class="text-center">
                            <div class="text-xs text-gray-500 mb-1">ç´¯è®¡ç•ªèŒ„æ•°</div>
                            <div class="text-3xl font-bold text-[#9373B7]" id="totalPomodoros">0</div>
                        </div>
                        <div class="text-center">
                            <div class="text-xs text-gray-500 mb-1">ç´¯è®¡ä¸“æ³¨å¤©æ•°</div>
                            <div class="text-3xl font-bold text-[#9373B7]" id="totalDays">0</div>
                        </div>
                        <div class="text-center">
                            <div class="text-xs text-gray-500 mb-1">ä»Šæ—¥ä¸“æ³¨</div>
                            <div class="text-2xl font-bold text-[#9373B7]" id="todayFocusTime">0h 0m</div>
                        </div>
                        <div class="text-center">
                            <div class="text-xs text-gray-500 mb-1">ç´¯è®¡ä¸“æ³¨æ—¶é•¿</div>
                            <div class="text-2xl font-bold text-[#9373B7]" id="totalFocusTime">0h</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- æ—¶é—´ç»´åº¦åˆ‡æ¢ -->
            <div class="px-4 mb-4">
                <div class="time-tab flex">
                    <button onclick="switchDataTimeTab('day')" id="dayTab" class="flex-1 time-tab-btn time-tab-active">æ—¥</button>
                    <button onclick="switchDataTimeTab('week')" id="weekTab" class="flex-1 time-tab-btn">å‘¨</button>
                    <button onclick="switchDataTimeTab('month')" id="monthTab" class="flex-1 time-tab-btn">æœˆ</button>
                    <button onclick="switchDataTimeTab('year')" id="yearTab" class="flex-1 time-tab-btn">å¹´</button>
                </div>
            </div>

            <!-- æ—¥æœŸé€‰æ‹©å™¨ -->
            <div class="px-4 mb-6">
                <div class="flex items-center justify-between">
                    <button onclick="previousDataDate()" class="glass-card rounded-full p-2 transition-all hover:scale-105">
                        <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                        </svg>
                    </button>
                    <div class="text-center">
                        <div id="dataDateDisplay" class="text-lg font-semibold text-[#9373B7]"></div>
                        <div id="focusDurationSummary" class="text-2xl font-bold text-[#9373B7] mt-1"></div>
                    </div>
                    <button onclick="nextDataDate()" class="glass-card rounded-full p-2 transition-all hover:scale-105">
                        <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- ä»»åŠ¡ç±»å‹é¥¼å›¾ -->
            <div class="px-4 mb-6">
                <div class="glass-card rounded-2xl p-4">
                    <h3 class="text-sm font-medium text-gray-600 mb-3">ä»»åŠ¡ç±»å‹åˆ†æ</h3>
                    <div class="chart-container" style="height: 360px; padding: 20px;">
                        <canvas id="taskPieChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- ä»Šæ—¥ä¸“æ³¨å±•ç¤º -->
            <div class="px-4 mb-6">
                <div class="glass-card rounded-2xl p-4">
                    <div class="flex justify-between items-center mb-4">
                        <div class="flex items-center gap-4">
                            <div>
                                <span class="text-sm text-gray-500">ä»Šæ—¥ä¸“æ³¨</span>
                                <div class="flex items-center gap-1 mt-1">
                                    <span class="text-2xl font-bold text-[#9373B7]" id="tomatoCountDisplay">0</span>
                                    <span class="tomato-icon"></span>
                                </div>
                            </div>
                            <div>
                                <span class="text-sm text-gray-500">æ”¾å¼ƒ</span>
                                <div class="flex items-center gap-1 mt-1">
                                    <span class="text-2xl font-bold text-gray-400" id="abandonCountDisplay">0</span>
                                    <span class="tomato-icon" style="background: #9ca3af;"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="tomatoGrid" class="grid grid-cols-12 gap-2 p-4 bg-gradient-to-br from-purple-50 to-pink-50 rounded-xl"></div>
                </div>
            </div>

            <!-- ä¸“æ³¨è¶‹åŠ¿æŠ˜çº¿å›¾ -->
            <div class="px-4 mb-6">
                <div class="glass-card rounded-2xl p-4">
                    <h3 class="text-sm font-medium text-gray-600 mb-3">ä¸“æ³¨è¶‹åŠ¿</h3>
                    <div style="height: 250px;">
                        <canvas id="focusTrendChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    `;
    
        // åˆå§‹åŒ–æ•°æ®ä¸­å¿ƒ
    // [ä¿®æ”¹] ä½¿ç”¨setTimeoutç¡®ä¿canvaså…ƒç´ å·²å‡†å¤‡å¥½
    setTimeout(initDataCenter, 50); 
}




// æ•°æ®ä¸­å¿ƒç›¸å…³å˜é‡
let currentDataTimeTab = 'day';
let currentDataDate = new Date();


// åˆå§‹åŒ–æ•°æ®ä¸­å¿ƒ
function initDataCenter() {
    // è®¾ç½®å½“å‰æ—¥æœŸ
    updateDataDateDisplay();
    
    // åŠ è½½ç»Ÿè®¡æ•°æ®
    loadDataStatistics();
    
    // åˆå§‹åŒ–å›¾è¡¨
    setTimeout(() => {
        renderDataCharts();
        updateTomatoDisplay();
        updateOCDataMessage();
    }, 100);
}

// åˆ‡æ¢æ—¶é—´ç»´åº¦
function switchDataTimeTab(tab) {
    document.querySelectorAll('.time-tab-btn').forEach(btn => btn.classList.remove('time-tab-active'));
    document.getElementById(tab + 'Tab').classList.add('time-tab-active');
    currentDataTimeTab = tab;
    currentDataDate = new Date();
    updateDataDateDisplay();
    loadDataStatistics();
    renderDataCharts();
}

// æ›´æ–°æ—¥æœŸæ˜¾ç¤º
function updateDataDateDisplay() {
    const dateDisplay = document.getElementById('dataDateDisplay');
    const formatDate = (date) => `${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥`;
    
    switch(currentDataTimeTab) {
        case 'day':
            dateDisplay.textContent = currentDataDate.toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' });
            break;
        case 'week':
            const dayOfWeek = currentDataDate.getDay() === 0 ? 7 : currentDataDate.getDay();
            const weekStart = new Date(currentDataDate);
            weekStart.setDate(currentDataDate.getDate() - dayOfWeek + 1);
            const weekEnd = new Date(weekStart);
            weekEnd.setDate(weekStart.getDate() + 6);
            dateDisplay.textContent = `${formatDate(weekStart)} - ${formatDate(weekEnd)}`;
            break;
        case 'month':
            dateDisplay.textContent = currentDataDate.toLocaleDateString('zh-CN', { year: 'numeric', month: 'long' });
            break;
        case 'year':
            dateDisplay.textContent = `${currentDataDate.getFullYear()}å¹´`;
            break;
    }
}

// æ—¥æœŸå¯¼èˆª
function previousDataDate() {
    const unit = { day: 1, week: 7, month: 1, year: 1 }[currentDataTimeTab];
    if (currentDataTimeTab === 'month') {
        currentDataDate.setMonth(currentDataDate.getMonth() - unit);
    } else if (currentDataTimeTab === 'year') {
        currentDataDate.setFullYear(currentDataDate.getFullYear() - unit);
    } else {
        currentDataDate.setDate(currentDataDate.getDate() - unit);
    }
    updateDataDateDisplay();
    loadDataStatistics();
    renderDataCharts();
}

function nextDataDate() {
    const unit = { day: 1, week: 7, month: 1, year: 1 }[currentDataTimeTab];
    if (currentDataTimeTab === 'month') {
        currentDataDate.setMonth(currentDataDate.getMonth() + unit);
    } else if (currentDataTimeTab === 'year') {
        currentDataDate.setFullYear(currentDataDate.getFullYear() + unit);
    } else {
        currentDataDate.setDate(currentDataDate.getDate() + unit);
    }
    if (currentDataDate > new Date()) currentDataDate = new Date();
    updateDataDateDisplay();
    loadDataStatistics();
    renderDataCharts();
}

// åŠ è½½å¹¶è®¡ç®—ç»Ÿè®¡æ•°æ®
// å¦‚æœå½“å‰åœ¨æ•°æ®ä¸­å¿ƒé¡µé¢ï¼Œåˆ™æ›´æ–°æ•°æ®
function updateDataCenterIfActive() {
    if (currentPage === 'dataCenter') {
        // å»¶è¿Ÿä¸€ç‚¹æ‰§è¡Œï¼Œç¡®ä¿æ•°æ®å·²ç»ä¿å­˜
        setTimeout(() => {
            loadDataStatistics();
            renderDataCharts();
            updateOCDataMessage();
        }, 100);
    }
}
function loadDataStatistics() {
    // è·å–çœŸå®æ•°æ®
    const stats = calculateStatistics(currentDataTimeTab, currentDataDate);
    
    // æ›´æ–°UIæ˜¾ç¤º
    document.getElementById('totalPomodoros').textContent = stats.totalPomodoros.toString();
    document.getElementById('totalDays').textContent = stats.totalDays.toString();
    document.getElementById('todayFocusTime').textContent = formatDuration(stats.todayFocusTime);
    document.getElementById('totalFocusTime').textContent = formatDuration(stats.totalFocusTime);
    document.getElementById('focusDurationSummary').textContent = formatDuration(stats.periodFocusTime);
    
    // æ›´æ–°ç•ªèŒ„å±•ç¤º
    updateTomatoDisplay(stats.periodPomodoros, stats.periodAbandoned);
}

// è®¡ç®—ç»Ÿè®¡æ•°æ®
function calculateStatistics(timeTab, date) {
    const allPomodoros = detailedStats.pomodoros || [];
    
    // è·å–ä»Šå¤©çš„æ•°æ®
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayPomodoros = allPomodoros.filter(p => {
        const pDate = new Date(p.date);
        pDate.setHours(0, 0, 0, 0);
        return pDate.getTime() === today.getTime();
    });
    
    // è·å–æŒ‡å®šæ—¶é—´æ®µçš„æ•°æ®
    const periodData = getPeriodData(timeTab, date, allPomodoros);
    
    // è®¡ç®—ç´¯è®¡æ•°æ®
    const totalPomodoros = allPomodoros.filter(p => p.status === 'completed').length;
    const totalFocusTime = allPomodoros.reduce((sum, p) => sum + (p.duration || 0), 0);
    
    // è®¡ç®—ç´¯è®¡å¤©æ•°ï¼ˆæœ‰è®°å½•çš„å¤©æ•°ï¼‰
    const uniqueDays = new Set();
    allPomodoros.forEach(p => {
        const date = new Date(p.date);
        uniqueDays.add(date.toDateString());
    });
    
    return {
        totalPomodoros: totalPomodoros,
        totalDays: uniqueDays.size,
        todayFocusTime: todayPomodoros.reduce((sum, p) => sum + (p.duration || 0), 0),
        totalFocusTime: totalFocusTime,
        periodFocusTime: periodData.focusTime,
        periodPomodoros: periodData.completed,
        periodAbandoned: periodData.abandoned,
        periodTaskStats: periodData.taskStats
    };
}

// è·å–æŒ‡å®šæ—¶é—´æ®µçš„æ•°æ®
function getPeriodData(timeTab, date, allPomodoros) {
    let startDate = new Date(date);
    let endDate = new Date(date);
    
    switch(timeTab) {
        case 'day':
            startDate.setHours(0, 0, 0, 0);
            endDate.setHours(23, 59, 59, 999);
            break;
        case 'week':
            const dayOfWeek = startDate.getDay() === 0 ? 7 : startDate.getDay();
            startDate.setDate(startDate.getDate() - dayOfWeek + 1);
            startDate.setHours(0, 0, 0, 0);
            endDate = new Date(startDate);
            endDate.setDate(endDate.getDate() + 6);
            endDate.setHours(23, 59, 59, 999);
            break;
        case 'month':
            startDate.setDate(1);
            startDate.setHours(0, 0, 0, 0);
            endDate = new Date(startDate.getFullYear(), startDate.getMonth() + 1, 0);
            endDate.setHours(23, 59, 59, 999);
            break;
        case 'year':
            startDate.setMonth(0, 1);
            startDate.setHours(0, 0, 0, 0);
            endDate = new Date(startDate.getFullYear(), 11, 31);
            endDate.setHours(23, 59, 59, 999);
            break;
    }
    
    // ç­›é€‰æ—¶é—´æ®µå†…çš„æ•°æ®
    const periodPomodoros = allPomodoros.filter(p => {
        const pDate = new Date(p.date);
        return pDate >= startDate && pDate <= endDate;
    });
    
    // ç»Ÿè®¡ä»»åŠ¡ç±»å‹
    const taskStats = {};
    periodPomodoros.forEach(p => {
        const status = p.statusName || 'å…¶ä»–';
        if (!taskStats[status]) {
            taskStats[status] = {
                count: 0,
                time: 0
            };
        }
        if (p.status === 'completed') {
            taskStats[status].count++;
        }
        taskStats[status].time += p.duration || 0;
    });
    
    return {
        focusTime: periodPomodoros.reduce((sum, p) => sum + (p.duration || 0), 0),
        completed: periodPomodoros.filter(p => p.status === 'completed').length,
        abandoned: periodPomodoros.filter(p => p.status === 'abandoned').length,
        taskStats: taskStats
    };
}

// æ ¼å¼åŒ–æ—¶é•¿æ˜¾ç¤º
function formatDuration(seconds) {
    if (seconds === 0) return '0m';
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    
    if (hours > 0) {
        return `${hours}h ${minutes}m`;
    } else {
        return `${minutes}m`;
    }
}

// æ›´æ–°ç•ªèŒ„å±•ç¤º
function updateTomatoDisplay(completed, abandoned) {
    const tomatoCountDisplay = document.getElementById('tomatoCountDisplay');
    const abandonCountDisplay = document.getElementById('abandonCountDisplay');
    const tomatoGrid = document.getElementById('tomatoGrid');
    
    if (tomatoCountDisplay) {
        tomatoCountDisplay.textContent = completed;
    }
    
    if (abandonCountDisplay) {
        abandonCountDisplay.textContent = abandoned;
    }
    
    if (tomatoGrid) {
        tomatoGrid.innerHTML = '';
        const total = Math.min(completed + abandoned, 36);
        
        for (let i = 0; i < completed && i < 36; i++) {
            const tomato = document.createElement('span');
            tomato.className = 'tomato-icon';
            tomatoGrid.appendChild(tomato);
        }
        
        for (let i = 0; i < abandoned && (i + completed) < 36; i++) {
            const tomato = document.createElement('span');
            tomato.className = 'tomato-icon';
            tomato.style.background = '#9ca3af';
            tomatoGrid.appendChild(tomato);
        }
    }
}

function renderDataCharts() {
    renderTaskPieChart();
    renderFocusTrendChart();
}

// æ¸²æŸ“ä»»åŠ¡ç±»å‹é¥¼å›¾
function renderTaskPieChart() {
    const ctx = document.getElementById('taskPieChart');
    if (!ctx) return;

    // [ä¿®æ”¹] ç›´æ¥åœ¨å‡½æ•°å†…éƒ¨å£°æ˜å®ä¾‹å˜é‡
    let taskPieChartInstance = Chart.getChart(ctx);
    if(taskPieChartInstance) {
        taskPieChartInstance.destroy();
    }

    const stats = calculateStatistics(currentDataTimeTab, currentDataDate);
    const taskStats = stats.periodTaskStats;
    
// [ä¿®æ”¹] å§‹ç»ˆåŸºäºçœŸå®æ•°æ®è®¡ç®—ï¼Œç§»é™¤æ¼”ç¤ºæ•°æ®
const labels = Object.keys(taskStats);
const data = labels.map(label => Math.floor(taskStats[label].time / 60)); // è½¬æ¢ä¸ºåˆ†é’Ÿ
const times = labels.map(label => formatDuration(taskStats[label].time));

const chartData = { labels, data, times };

    
    const PIE_CHART_COLORS = ['#dae67a', '#b8bae1', '#e8b5d6', '#eb70a7', '#787cb1', '#cba2b4', '#f9c89b', '#fff297'];
    const selectedColors = PIE_CHART_COLORS.slice(0, chartData.labels.length);
    
    taskPieChartInstance = new Chart(ctx, {
        type: 'pie',
        data: {
            labels: chartData.labels,
            datasets: [{
                data: chartData.data,
                backgroundColor: selectedColors,
                borderWidth: 2,
                borderColor: '#fff'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: { padding: 40 },
            plugins: {
                legend: { display: false },
                datalabels: {
                    display: true,
                    color: '#333',
                    font: { size: 11, weight: '500' },
                    formatter: (value, context) => `${chartData.labels[context.dataIndex]}\n${chartData.times[context.dataIndex]}`,
                    anchor: 'end',
                    align: 'end',
                    offset: 10,
                    textAlign: 'center',
                    clip: false
                }
            }
        }
    });
}



// æ¸²æŸ“ä¸“æ³¨è¶‹åŠ¿æŠ˜çº¿å›¾
function renderFocusTrendChart() {
    const ctx = document.getElementById('focusTrendChart');
    if (!ctx) return;
    
    // [ä¿®æ”¹] ç›´æ¥åœ¨å‡½æ•°å†…éƒ¨å£°æ˜å®ä¾‹å˜é‡
    let focusTrendChartInstance = Chart.getChart(ctx);
    if(focusTrendChartInstance) {
        focusTrendChartInstance.destroy();
    }

    const trendData = getTrendData(currentDataTimeTab, currentDataDate);
    
    focusTrendChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
            labels: trendData.labels,
            datasets: [{
                label: 'ä¸“æ³¨æ•ˆç‡(%)',
                data: trendData.data,
                borderColor: 'rgba(183, 148, 246, 0.8)',
                backgroundColor: 'rgba(183, 148, 246, 0.1)',
                borderWidth: 2,
                fill: true,
                tension: 0.4,
                pointBackgroundColor: 'rgba(183, 148, 246, 1)',
                pointBorderColor: '#fff',
                pointBorderWidth: 2
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                datalabels: { display: false }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    grid: { color: 'rgba(183, 148, 246, 0.1)' },
                    ticks: { color: '#666' }
                },
                x: {
                    grid: { display: false },
                    ticks: { color: '#666' }
                }
            }
        }
    });
}



// è·å–è¶‹åŠ¿æ•°æ®
function getTrendData(timeTab, date) {
    const allPomodoros = detailedStats.pomodoros || [];
    

    
    // åŸºäºçœŸå®æ•°æ®è®¡ç®—è¶‹åŠ¿ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
    switch(timeTab) {
        case 'day':
            return calculateDayTrend(date, allPomodoros);
        case 'week':
            return calculateWeekTrend(date, allPomodoros);
        case 'month':
            return calculateMonthTrend(date, allPomodoros);
        case 'year':
            return calculateYearTrend(date, allPomodoros);
        default:
            return { labels: [], data: [] };
    }
}

// è®¡ç®—æ—¥è¶‹åŠ¿æ•°æ®
function calculateDayTrend(date, allPomodoros) {
    const labels = ['6æ—¶', '9æ—¶', '12æ—¶', '15æ—¶', '18æ—¶', '21æ—¶'];
    const hours = [6, 9, 12, 15, 18, 21];
    const data = [];
    
    const targetDate = new Date(date);
    
    hours.forEach(hour => {
        const hourStart = new Date(targetDate);
        hourStart.setHours(hour, 0, 0, 0);
        const hourEnd = new Date(targetDate);
        hourEnd.setHours(hour + 2, 59, 59, 999); // 3å°æ—¶æ—¶é—´æ®µ
        
        const hourPomodoros = allPomodoros.filter(p => {
            const pDate = new Date(p.date);
            return pDate >= hourStart && pDate <= hourEnd;
        });
        
        const completed = hourPomodoros.filter(p => p.status === 'completed').length;
        const total = hourPomodoros.length;
        const efficiency = total > 0 ? Math.round((completed / total) * 100) : 0;
        
        data.push(efficiency);
    });
    
    return { labels, data };
}

// è®¡ç®—å‘¨è¶‹åŠ¿æ•°æ®
function calculateWeekTrend(date, allPomodoros) {
    const labels = ['å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­', 'å‘¨æ—¥'];
    const data = [];
    
    const weekStart = new Date(date);
    const dayOfWeek = weekStart.getDay() === 0 ? 7 : weekStart.getDay();
    weekStart.setDate(weekStart.getDate() - dayOfWeek + 1);
    
    for (let i = 0; i < 7; i++) {
        const dayStart = new Date(weekStart);
        dayStart.setDate(weekStart.getDate() + i);
        dayStart.setHours(0, 0, 0, 0);
        
        const dayEnd = new Date(dayStart);
        dayEnd.setHours(23, 59, 59, 999);
        
        const dayPomodoros = allPomodoros.filter(p => {
            const pDate = new Date(p.date);
            return pDate >= dayStart && pDate <= dayEnd;
        });
        
        const completed = dayPomodoros.filter(p => p.status === 'completed').length;
        const total = dayPomodoros.length;
        const efficiency = total > 0 ? Math.round((completed / total) * 100) : 0;
        
        data.push(efficiency);
    }
    
    return { labels, data };
}

// è®¡ç®—æœˆè¶‹åŠ¿æ•°æ®ï¼ˆæŒ‰å‘¨ï¼‰
function calculateMonthTrend(date, allPomodoros) {
    const labels = ['ç¬¬1å‘¨', 'ç¬¬2å‘¨', 'ç¬¬3å‘¨', 'ç¬¬4å‘¨'];
    const data = [];
    
    const monthStart = new Date(date.getFullYear(), date.getMonth(), 1);
    
    for (let week = 0; week < 4; week++) {
        const weekStart = new Date(monthStart);
        weekStart.setDate(monthStart.getDate() + week * 7);
        
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekStart.getDate() + 6);
        weekEnd.setHours(23, 59, 59, 999);
        
        const weekPomodoros = allPomodoros.filter(p => {
            const pDate = new Date(p.date);
            return pDate >= weekStart && pDate <= weekEnd;
        });
        
        const completed = weekPomodoros.filter(p => p.status === 'completed').length;
        const total = weekPomodoros.length;
        const efficiency = total > 0 ? Math.round((completed / total) * 100) : 0;
        
        data.push(efficiency);
    }
    
    return { labels, data };
}

// è®¡ç®—å¹´è¶‹åŠ¿æ•°æ®ï¼ˆæŒ‰æœˆï¼‰
function calculateYearTrend(date, allPomodoros) {
    const labels = ['1æœˆ', '2æœˆ', '3æœˆ', '4æœˆ', '5æœˆ', '6æœˆ', '7æœˆ', '8æœˆ', '9æœˆ', '10æœˆ', '11æœˆ', '12æœˆ'];
    const data = [];
    
    for (let month = 0; month < 12; month++) {
        const monthStart = new Date(date.getFullYear(), month, 1);
        const monthEnd = new Date(date.getFullYear(), month + 1, 0);
        monthEnd.setHours(23, 59, 59, 999);
        
        const monthPomodoros = allPomodoros.filter(p => {
            const pDate = new Date(p.date);
            return pDate >= monthStart && pDate <= monthEnd;
        });
        
        const completed = monthPomodoros.filter(p => p.status === 'completed').length;
        const total = monthPomodoros.length;
        const efficiency = total > 0 ? Math.round((completed / total) * 100) : 0;
        
        data.push(efficiency);
    }
    
    return { labels, data };
}



function updateTomatoDisplay(completed, abandoned) {
    // å¦‚æœæ²¡æœ‰ä¼ å…¥å‚æ•°ï¼Œåˆ™è®¡ç®—ä»Šæ—¥æ•°æ®
    if (completed === undefined || abandoned === undefined) {
        const todayData = getTodayPomodoroData();
        completed = todayData.completed;
        abandoned = todayData.abandoned;
    }
    
    const tomatoCountDisplay = document.getElementById('tomatoCountDisplay');
    const abandonCountDisplay = document.getElementById('abandonCountDisplay');
    const tomatoGrid = document.getElementById('tomatoGrid');
    
    if (tomatoCountDisplay) {
        tomatoCountDisplay.textContent = completed;
    }
    
    if (abandonCountDisplay) {
        abandonCountDisplay.textContent = abandoned;
    }
    
    if (tomatoGrid) {
        tomatoGrid.innerHTML = '';
        const total = Math.min(completed + abandoned, 36);
        
        // æ˜¾ç¤ºå®Œæˆçš„ç•ªèŒ„é’Ÿï¼ˆçº¢è‰²ï¼‰
        for (let i = 0; i < completed && i < 36; i++) {
            const tomato = document.createElement('span');
            tomato.className = 'tomato-icon';
            tomatoGrid.appendChild(tomato);
        }
        
        // æ˜¾ç¤ºæ”¾å¼ƒçš„ç•ªèŒ„é’Ÿï¼ˆç°è‰²ï¼‰
        for (let i = 0; i < abandoned && (i + completed) < 36; i++) {
            const tomato = document.createElement('span');
            tomato.className = 'tomato-icon';
            tomato.style.background = '#9ca3af';
            tomatoGrid.appendChild(tomato);
        }
    }
}

// è·å–ä»Šæ—¥ç•ªèŒ„é’Ÿæ•°æ®çš„è¾…åŠ©å‡½æ•°
function getTodayPomodoroData() {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayEnd = new Date(today);
    todayEnd.setHours(23, 59, 59, 999);
    
    const allPomodoros = detailedStats.pomodoros || [];
    const todayPomodoros = allPomodoros.filter(p => {
        const pDate = new Date(p.date);
        return pDate >= today && pDate <= todayEnd;
    });
    
    return {
        completed: todayPomodoros.filter(p => p.status === 'completed').length,
        abandoned: todayPomodoros.filter(p => p.status === 'abandoned').length
    };
}

function updateOCDataMessage() {
    const messages = {
        day: "ä»Šå¤©çš„ä¸“æ³¨çŠ¶æ€å¾ˆæ£’å“¦ï¼ä¸Šåˆçš„å­¦ä¹ æ•ˆç‡ç‰¹åˆ«é«˜ï¼Œç»§ç»­ä¿æŒè¿™ä¸ªèŠ‚å¥ï½è®°å¾—é€‚å½“ä¼‘æ¯ï¼ŒåŠ³é€¸ç»“åˆæ‰èƒ½èµ°å¾—æ›´è¿œå‘¢ã€‚",
        week: "è¿™å‘¨çš„è¡¨ç°çœŸçš„å¾ˆç¨³å®šï¼å‘¨å››çš„ä¸“æ³¨åº¦è¾¾åˆ°äº†å³°å€¼ï¼Œçœ‹æ¥æ‰¾åˆ°é€‚åˆè‡ªå·±çš„èŠ‚å¥äº†ã€‚å‘¨æœ«ä¹Ÿåˆ«å¿˜äº†ä¿æŒå­¦ä¹ å“¦ï½",
        month: "å“‡ï¼è¿™ä¸ªæœˆç´¯è®¡ä¸“æ³¨æ—¶é•¿è¶…è¿‡85å°æ—¶äº†ï¼ŒçœŸæ˜¯äº†ä¸èµ·çš„åšæŒï¼çœ‹åˆ°ä½ åœ¨ä¸æ–­è¿›æ­¥ï¼Œæˆ‘ä¹Ÿä¸ºä½ æ„Ÿåˆ°å¼€å¿ƒï½",
        year: "ä¸€å¹´3200ä¸ªç•ªèŒ„ï¼æ¯ä¸€ä¸ªéƒ½è§è¯äº†ä½ çš„æˆé•¿ã€‚æ–°çš„ä¸€å¹´ï¼Œè®©æˆ‘ä»¬ä¸€èµ·åˆ›é€ æ›´å¤šç¾å¥½çš„ä¸“æ³¨æ—¶å…‰å§ï¼"
    };
    
    const messageElement = document.getElementById('ocDataMessage');
    if (messageElement) {
        messageElement.textContent = messages[currentDataTimeTab] || messages.day;
    }
}

 function goBackToHome() {
     showPage('homePage');
     if (timerInterval) {
         clearInterval(timerInterval);
         timerInterval = null;
         isTimerRunning = false;
         isPaused = false;
         
         if (focusStartTime) {
             const focusedSeconds = Math.floor((Date.now() - focusStartTime) / 1000);
             addFocusTime(focusedSeconds);
             focusStartTime = null;
         }
         
         resetToSingleButton();
         enableModeSwitch();
         stopHeartbeatAnimation();
         stopEncourageLoop();
     }
     
     document.getElementById('statusSelector').classList.remove('show');
     document.getElementById('timeSelector').classList.remove('show');
     document.getElementById('taskSelector').classList.remove('show');
     
     // é‡ç½®çŠ¶æ€
     isStatusSelected = false;
     currentStatus = { name: '', icon: 'âšª' };
     const statusButton = document.getElementById('statusButton');
     statusButton.innerHTML = '<span class="oc-status-pure-text">çŠ¶æ€å¾…é€‰æ‹©</span> <span class="oc-status-emoji">âšª</span>';
     
     const startBtnHint = document.getElementById('startBtnHint');
     if (startBtnHint) {
         startBtnHint.classList.add('hidden');
     }
     
     resetOCInteraction();
 }

 function goBackHome() {
     goBackToHome();
 }

 function goBackToOCCards() {
     showPage('ocCardsPage');
 }

 // OCå¡ç‰‡ç›¸å…³å‡½æ•°
 function renderOCCards() {
     const grid = document.getElementById('ocCardsGrid');
     const createCard = grid.querySelector('.create-card');
     grid.innerHTML = '';
     grid.appendChild(createCard);
     
     ocData.forEach((oc, index) => {
         const card = document.createElement('div');
         card.className = 'oc-card';
         card.innerHTML = `
             <div class="flex items-center space-x-3">
                 <img src="${oc.avatar}" alt="${oc.name}" class="oc-card-avatar" onclick="editOC(${index})">
                 <div class="flex-1" onclick="editOC(${index})">
                     <h3 class="font-semibold text-slate-800 mb-1">${oc.name}</h3>
                     <p class="text-xs text-slate-500">ä½ çš„å­¦ä¹ æ­å­</p>
                 </div>
                 <div class="w-6 h-6 rounded-full border-2 flex items-center justify-center cursor-pointer transition-all ${
                     oc.selected ? 'border-purple-500 bg-purple-500' : 'border-slate-300'
                 }" onclick="selectOC(${index})">
                     ${oc.selected ? '<svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>' : ''}
                 </div>
             </div>
         `;
         grid.appendChild(card);
     });
 }

 function selectOC(index) {
     ocData.forEach((oc, i) => {
         oc.selected = i === index;
     });
     
     currentOCIndex = index;
     updateCurrentOC(index);
     renderOCCards();
     
     localStorage.setItem('ocData', JSON.stringify(ocData));
     localStorage.setItem('currentOCIndex', index.toString());
 }

 function createNewOC() {
     editingOCIndex = -1;
     const newOC = {
         id: Date.now(),
         name: 'æ–°OC',
         avatar: 'https://images.unsplash.com/photo-1494790108755-2616c359140b?w=200&h=200&fit=crop&crop=face',
         userTitle: 'å¤§å°å§',
         customGreeting: '',
         encourageStyles: ['gentle'],
         reminderStyles: ['guardian'],
         customGifts: '',
         selected: false
     };
     
     document.getElementById('ocNameInput').value = newOC.name;
     document.getElementById('userTitleInput').value = newOC.userTitle;
     document.getElementById('customGreeting').value = newOC.customGreeting;
     document.getElementById('customGiftsInput').value = newOC.customGifts;
     document.getElementById('avatarPreview').src = newOC.avatar;
     
     // é‡ç½®é£æ ¼é€‰æ‹©
     resetStyleSelections();
     selectStyleOptions('encourageStyleGrid', newOC.encourageStyles);
     selectStyleOptions('reminderStyleGrid', newOC.reminderStyles);
     
     showPage('ocSettingPage');
     
     // æ¸²æŸ“è‡ªå®šä¹‰é£æ ¼å’ŒçŠ¶æ€ç¤¼ç‰©
     setTimeout(() => {
renderCustomStylesInGrid('encourage');
renderCustomStylesInGrid('remind');
loadStatusGiftsFromStorage();
// åªéœ€è¦è°ƒç”¨ä¸€æ¬¡åˆå§‹åŒ–ï¼Œå†…éƒ¨ä¼šå¤„ç†äº‹ä»¶ç»‘å®š
initializeStatusGiftPreviews();
}, 150);
 }

 function editOC(index) {
     editingOCIndex = index;
     const oc = ocData[index];
     
     document.getElementById('ocNameInput').value = oc.name;
     document.getElementById('userTitleInput').value = oc.userTitle;
     document.getElementById('customGreeting').value = oc.customGreeting || '';
     document.getElementById('customGiftsInput').value = oc.customGifts || '';
     document.getElementById('avatarPreview').src = oc.avatar;
     
     // è®¾ç½®é£æ ¼é€‰æ‹©
     resetStyleSelections();
     selectStyleOptions('encourageStyleGrid', oc.encourageStyles || ['gentle']);
     selectStyleOptions('reminderStyleGrid', oc.reminderStyles || ['guardian']);
     
     showPage('ocSettingPage');
     
     // æ¸²æŸ“è‡ªå®šä¹‰é£æ ¼å’ŒçŠ¶æ€ç¤¼ç‰©
     setTimeout(() => {
renderCustomStylesInGrid('encourage');
renderCustomStylesInGrid('remind');
loadStatusGiftsFromStorage();
// åªéœ€è¦è°ƒç”¨ä¸€æ¬¡åˆå§‹åŒ–ï¼Œå†…éƒ¨ä¼šå¤„ç†äº‹ä»¶ç»‘å®š
initializeStatusGiftPreviews();
}, 150);
 }

 function resetStyleSelections() {
     document.querySelectorAll('.style-option').forEach(option => {
         option.classList.remove('selected');
     });
 }

 function selectStyleOptions(gridId, styles) {
     const grid = document.getElementById(gridId);
     if (!grid) return;
     
     styles.forEach(style => {
         const option = grid.querySelector(`[data-style="${style}"]`);
         if (option) {
             option.classList.add('selected');
         }
     });
 }

 function getSelectedStyles(gridId) {
     const grid = document.getElementById(gridId);
     if (!grid) return [];
     
     const selectedOptions = grid.querySelectorAll('.style-option.selected');
     return Array.from(selectedOptions).map(option => option.dataset.style);
 }

 function uploadAvatar() {
     document.getElementById('avatarInput').click();
 }

 function previewAvatar(event) {
     const file = event.target.files[0];
     if (file && file.type.startsWith('image/')) {
         const reader = new FileReader();
         reader.onload = function(e) {
             document.getElementById('avatarPreview').src = e.target.result;
         };
         reader.readAsDataURL(file);
     }
 }

 function saveOCSettings() {
     const ocSettings = {
         name: document.getElementById('ocNameInput').value.trim(),
         avatar: document.getElementById('avatarPreview').src,
         userTitle: document.getElementById('userTitleInput').value.trim(),
         customGreeting: document.getElementById('customGreeting').value.trim(),
         encourageStyles: getSelectedStyles('encourageStyleGrid'),
         reminderStyles: getSelectedStyles('reminderStyleGrid'),
         customGifts: document.getElementById('customGiftsInput').value.trim()
     };

     if (!ocSettings.name) {
         alert('è¯·è¾“å…¥OCåå­—');
         return;
     }

     if (ocSettings.encourageStyles.length === 0) {
         alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ç§é¼“åŠ±é£æ ¼');
         return;
     }

     if (ocSettings.reminderStyles.length === 0) {
         alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ç§ç£ä¿ƒé£æ ¼');
         return;
     }

     if (editingOCIndex === -1) {
         ocSettings.id = Date.now();
         ocSettings.selected = false;
         ocData.push(ocSettings);
     } else {
         ocData[editingOCIndex] = { ...ocData[editingOCIndex], ...ocSettings };
     }

     localStorage.setItem('ocData', JSON.stringify(ocData));
     
     if (editingOCIndex === currentOCIndex || editingOCIndex === -1) {
         updateCurrentOC(editingOCIndex === -1 ? ocData.length - 1 : editingOCIndex);
     }

     const saveBtn = event.currentTarget;
     const originalContent = saveBtn.innerHTML;
     saveBtn.innerHTML = '<span class="text-green-500">å·²ä¿å­˜ âœ“</span>';
     setTimeout(() => {
         saveBtn.innerHTML = originalContent;
         goBackToOCCards();
     }, 1000);
 }

 function deleteOC() {
     if (editingOCIndex === -1) return;
     
     if (ocData.length <= 1) {
         alert('è‡³å°‘éœ€è¦ä¿ç•™ä¸€ä¸ªOC');
         return;
     }
     
     if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªOCå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) {
         ocData.splice(editingOCIndex, 1);
         
         if (editingOCIndex === currentOCIndex) {
             ocData[0].selected = true;
             updateCurrentOC(0);
         } else if (editingOCIndex < currentOCIndex) {
             currentOCIndex--;
         }
         
         localStorage.setItem('ocData', JSON.stringify(ocData));
         
         goBackToOCCards();
     }
 }

 function updateCurrentOC(index) {
     currentOCIndex = index;
     const oc = ocData[index];
     
     document.getElementById('currentOCAvatar').src = oc.avatar;
     document.getElementById('currentOCName').textContent = oc.name;
     
     let greeting;
     if (oc.customGreeting && oc.customGreeting.trim()) {
         greeting = oc.customGreeting;
     } else {
         const hour = new Date().getHours();
         const title = oc.userTitle || 'å¤§å°å§';
         if (hour < 12) {
             greeting = `æ—©å®‰ï¼Œ${title}ï¼`;
         } else if (hour < 18) {
             greeting = `ä¸‹åˆå¥½ï¼Œ${title}ï¼`;
         } else {
             greeting = `æ™šä¸Šå¥½ï¼Œ${title}ï¼`;
         }
     }
     document.getElementById('currentOCGreeting').textContent = greeting;
     
     if (document.getElementById('focusOCAvatar')) {
         document.getElementById('focusOCAvatar').src = oc.avatar;
     }
     
     if (document.getElementById('ocMessageText') && currentPage === 'focus') {
         const ocMessageElement = document.getElementById('ocMessageText');
         if (ocMessageElement.textContent.includes('å¿«å¼€å§‹å­¦ä¹ å§') || currentMessageType === 'initial') {
             ocMessageElement.innerHTML = `<span class="oc-message-text-wrapper">${getInitialMessage()}</span>`;
         }
     }
     
     localStorage.setItem('currentOCIndex', index.toString());
 }

 // è®¡æ—¶å™¨ç›¸å…³å‡½æ•°
 function updateTimerDisplay() {
     const minutes = Math.floor(currentTime / 60);
     const seconds = currentTime % 60;
     const display = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
     document.getElementById('timerDisplay').textContent = display;
 }

 function switchMode(mode) {
     if (isTimerRunning) return;
     
     currentMode = mode;
     const pomodoroBtn = document.getElementById('pomodoroBtn');
     const timerBtn = document.getElementById('timerBtn');
     
     if (mode === 'pomodoro') {
         pomodoroBtn.classList.add('mode-active');
         pomodoroBtn.classList.remove('text-slate-600');
         timerBtn.classList.remove('mode-active');
         timerBtn.classList.add('text-slate-600');
         currentTime = selectedMinutes * 60;
         updateTimerDisplay();
     } else {
         timerBtn.classList.add('mode-active');
         timerBtn.classList.remove('text-slate-600');
         pomodoroBtn.classList.remove('mode-active');
         pomodoroBtn.classList.add('text-slate-600');
         currentTime = 0;
         updateTimerDisplay();
     }
 }

 function toggleTimeSelector() {
     if (isTimerRunning) return;
     
     const selector = document.getElementById('timeSelector');
     const isVisible = selector.classList.contains('show');
     
     if (isVisible) {
         selector.classList.remove('show');
     } else {
         selector.classList.add('show');
         document.getElementById('statusSelector').classList.remove('show');
         document.getElementById('taskSelector').classList.remove('show');
     }
 }

 function selectTime(minutes) {
     if (isTimerRunning) return;
     
     selectedMinutes = minutes;
     currentTime = minutes * 60;
     updateTimerDisplay();
     
     document.querySelectorAll('.time-option').forEach(option => {
         option.classList.remove('active');
     });
     event.currentTarget.classList.add('active');
     
     document.getElementById('timeSelector').classList.remove('show');
 }

 function handleCustomTimeEnter(event) {
     if (event.key === 'Enter') {
         selectCustomTime();
     }
 }

 function selectCustomTime() {
     if (isTimerRunning) return;
     
     const customInput = document.getElementById('customTimeInput');
     const customValue = parseInt(customInput.value);
     
     if (isNaN(customValue) || customValue < 1 || customValue > 120) {
         alert('è¯·è¾“å…¥1-120ä¹‹é—´çš„æ•°å€¼');
         customInput.focus();
         return;
     }
     
     selectedMinutes = customValue;
     currentTime = customValue * 60;
     updateTimerDisplay();
     
     document.querySelectorAll('.time-option').forEach(option => {
         option.classList.remove('active');
     });
     
     document.getElementById('timeSelector').classList.remove('show');
 }

 function showTaskSelector() {
     const selector = document.getElementById('taskSelector');
     const isVisible = selector.classList.contains('show');
     
     if (isVisible) {
         selector.classList.remove('show');
     } else {
         selector.classList.add('show');
         document.getElementById('statusSelector').classList.remove('show');
         document.getElementById('timeSelector').classList.remove('show');
     }
 }

 function selectTask(name, status, color) {
     currentTask = { name, status, color };
     
     document.getElementById('currentTaskName').textContent = name;
     const statusElement = document.getElementById('currentTaskStatus');
     statusElement.textContent = status;
     
     statusElement.className = 'text-xs px-2 py-1 rounded-full';
     if (color === 'slate') {
         statusElement.classList.add('text-slate-500', 'bg-slate-100');
     } else {
         statusElement.classList.add('text-blue-500', 'bg-blue-100');
     }
     
     document.querySelectorAll('.task-option').forEach(option => {
         option.classList.remove('active');
     });
     event.currentTarget.classList.add('active');
     
     document.getElementById('taskSelector').classList.remove('show');
 }

 function toggleStatusSelector() {
     const selector = document.getElementById('statusSelector');
     const isVisible = selector.classList.contains('show');
     
     if (isVisible) {
         selector.classList.remove('show');
     } else {
         selector.classList.add('show');
         document.getElementById('timeSelector').classList.remove('show');
         document.getElementById('taskSelector').classList.remove('show');
     }
 }

 function selectStatus(name, icon) {
     currentStatus = { name, icon };
     isStatusSelected = true;
     
     const startBtnHint = document.getElementById('startBtnHint');
     startBtnHint.classList.add('hidden');
     
     const currentOC = ocData[currentOCIndex];
     const ocName = currentOC.name;
     
     let statusText;
     if (name === 'å­¦ä¹ ' || name === 'å·¥ä½œ') {
         statusText = `${ocName}ä¸“æ³¨${name}ä¸­`;
     } else {
         statusText = `${ocName}${name}ä¸­`;
     }
     
     // ä½¿ç”¨ä¼˜åŒ–çš„çŠ¶æ€æ–‡å­—è®¾ç½®
     const statusButton = document.getElementById('statusButton');
     statusButton.innerHTML = `<span class="oc-status-pure-text">${statusText}</span> <span class="oc-status-emoji">${icon}</span>`;
     
     document.querySelectorAll('.status-option').forEach(option => {
         option.classList.remove('active');
     });
     event.currentTarget.classList.add('active');
     
     document.getElementById('statusSelector').classList.remove('show');
     
     if (!isTimerRunning && !isIgnoring) {
         showOCMessage(getInitialMessage(), 'initial', true);
     }
 }
 
 function showCustomStatusInput() {
     const customInput = document.getElementById('customStatusInput');
     const statusGrid = document.querySelector('.status-grid');
     
     statusGrid.style.display = 'none';
     customInput.classList.remove('hidden');
     
     document.getElementById('customStatusText').focus();
 }
 
 function handleCustomStatusEnter(event) {
     if (event.key === 'Enter') {
         confirmCustomStatus();
     }
 }
 
 function confirmCustomStatus() {
     const customText = document.getElementById('customStatusText').value.trim();
     if (!customText) {
         alert('è¯·è¾“å…¥çŠ¶æ€å†…å®¹');
         return;
     }
     
     if (customText.length > 10) {
         alert('çŠ¶æ€å†…å®¹ä¸èƒ½è¶…è¿‡10ä¸ªå­—ç¬¦');
         return;
     }
     
     selectCustomStatus(customText, 'âœ¨');
     hideCustomStatusInput();
 }
 
 function cancelCustomStatus() {
     hideCustomStatusInput();
 }
 
 function hideCustomStatusInput() {
     const customInput = document.getElementById('customStatusInput');
     const statusGrid = document.querySelector('.status-grid');
     
     statusGrid.style.display = 'grid';
     customInput.classList.add('hidden');
     
     document.getElementById('customStatusText').value = '';
 }
 
 function selectCustomStatus(name, icon) {
     currentStatus = { name, icon };
     isStatusSelected = true;
     
     const startBtnHint = document.getElementById('startBtnHint');
     startBtnHint.classList.add('hidden');
     
     const currentOC = ocData[currentOCIndex];
     const ocName = currentOC.name;
     const statusText = `${ocName}${name}ä¸­`;
     
     // ä½¿ç”¨ä¼˜åŒ–çš„çŠ¶æ€æ–‡å­—è®¾ç½®
     const statusButton = document.getElementById('statusButton');
     statusButton.innerHTML = `<span class="oc-status-pure-text">${statusText}</span> <span class="oc-status-emoji">${icon}</span>`;
     
     document.getElementById('statusSelector').classList.remove('show');
     
     if (!isTimerRunning && !isIgnoring) {
         showOCMessage(getInitialMessage(), 'initial', true);
     }
 }

 function startStopTimer() {
     // å°è¯•å¯åŠ¨èƒŒæ™¯éŸ³ä¹ï¼ˆè§£å†³æµè§ˆå™¨è‡ªåŠ¨æ’­æ”¾é™åˆ¶ï¼‰
if (currentMusicMode > 0 && !currentBackgroundMusic && isStatusSelected) {
 const musicType = currentMusicMode === 1 ? 'music' : 'rain';
 playBackgroundMusic(musicType);
}
     if (!isStatusSelected) {
         const startBtnHint = document.getElementById('startBtnHint');
         startBtnHint.classList.remove('hidden');
         
         const startBtn = document.getElementById('startBtn');
         startBtn.classList.add('vibration');
         setTimeout(() => {
             startBtn.classList.remove('vibration');
         }, 500);
         
         return;
     }
     
     if (!isTimerRunning) {
         isTimerRunning = true;
         isPaused = false;
         focusStartTime = Date.now();
         focusStartOCIndex = currentOCIndex;
         startHeartbeatAnimation();
         startEncourageLoop();
         
         document.getElementById('singleButtonLayout').classList.add('hidden');
         document.getElementById('threeButtonLayout').classList.remove('hidden');
         
         document.getElementById('pomodoroBtn').style.pointerEvents = 'none';
         document.getElementById('timerBtn').style.pointerEvents = 'none';
         document.getElementById('pomodoroBtn').style.opacity = '0.6';
         document.getElementById('timerBtn').style.opacity = '0.6';
         
         timerInterval = setInterval(() => {
             if (currentMode === 'pomodoro') {
                 currentTime--;
                 if (currentTime <= 0) {
                     clearInterval(timerInterval);
                     isTimerRunning = false;
                     isPaused = false;
                     
                     if (focusStartTime) {
                         const focusedSeconds = selectedMinutes * 60;
                         addFocusTime(focusedSeconds);
                         focusStartTime = null;
                     }
                     
                     showPomodoroComplete();
                     enableModeSwitch();
                     resetToSingleButton();
                     stopHeartbeatAnimation();
                     stopEncourageLoop();
                     return;
                 }
             } else {
                 currentTime++;
             }
             updateTimerDisplay();
         }, 1000);
     }
 }

 function pauseResumeTimer() {
if (isTimerRunning) {
 clearInterval(timerInterval);
 isTimerRunning = false;
 isPaused = true;
 stopHeartbeatAnimation();
 stopEncourageLoop();
 // ä¿®æ”¹ï¼šæš‚åœèƒŒæ™¯éŸ³ä¹ä½†ä¿ç•™è¿›åº¦
 pauseBackgroundMusic();
 
 if (focusStartTime) {
     const focusedSeconds = Math.floor((Date.now() - focusStartTime) / 1000);
     addFocusTime(focusedSeconds);
     focusStartTime = null;
 }
 
 showRestMessage();
 
 document.getElementById('pauseBtn').innerHTML = `
     <svg class="w-8 h-8" fill="white" viewBox="0 0 24 24">
         <path d="M8 5v14l11-7z"/>
     </svg>
 `;
 enableModeSwitch();
} else if (isPaused) {
 isTimerRunning = true;
 isPaused = false;
 focusStartTime = Date.now();
 startHeartbeatAnimation();
 startEncourageLoop();
 // æ–°å¢ï¼šæ¢å¤èƒŒæ™¯éŸ³ä¹æ’­æ”¾
 resumeBackgroundMusic();
 
 document.getElementById('pauseBtn').innerHTML = `
     <svg class="w-8 h-8" fill="white" viewBox="0 0 24 24">
         <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
     </svg>
 `;
 
 document.getElementById('pomodoroBtn').style.pointerEvents = 'none';
 document.getElementById('timerBtn').style.pointerEvents = 'none';
 document.getElementById('pomodoroBtn').style.opacity = '0.6';
 document.getElementById('timerBtn').style.opacity = '0.6';
 
 timerInterval = setInterval(() => {
     if (currentMode === 'pomodoro') {
         currentTime--;
         if (currentTime <= 0) {
             clearInterval(timerInterval);
             isTimerRunning = false;
             isPaused = false;
             
             if (focusStartTime) {
                 const focusedSeconds = Math.floor((Date.now() - focusStartTime) / 1000);
                 addFocusTime(focusedSeconds);
                 focusStartTime = null;
             }
             
             showPomodoroComplete();
             enableModeSwitch();
             resetToSingleButton();
             stopHeartbeatAnimation();
             stopEncourageLoop();
             return;
         }
     } else {
         currentTime++;
     }
     updateTimerDisplay();
 }, 1000);
}
}

function stopTimer() {
if (timerInterval) {
 clearInterval(timerInterval);
 timerInterval = null;
 
 if (focusStartTime) {
     const focusedSeconds = Math.floor((Date.now() - focusStartTime) / 1000);
     addFocusTime(focusedSeconds);

     // æ–°å¢ï¼šå¦‚æœæ˜¯æ‰‹åŠ¨åœæ­¢ï¼Œè®°å½•ä¸ºæ”¾å¼ƒçš„ç•ªèŒ„é’Ÿ
    if (isTimerRunning && currentMode === 'pomodoro' && focusedSeconds > 60) {
        recordAbandonedPomodoro(focusedSeconds, currentTask.name, currentStatus.name);
    }
    // æ›´æ–°æ•°æ®ä¸­å¿ƒé¡µé¢ï¼ˆå¦‚æœå½“å‰åœ¨æ•°æ®ä¸­å¿ƒé¡µé¢ï¼‰
updateDataCenterIfActive();

     focusStartTime = null;
 }
}
isTimerRunning = false;
isPaused = false;

stopHeartbeatAnimation();
stopEncourageLoop();
// ä¿®æ”¹ï¼šåœæ­¢éŸ³ä¹å¹¶é‡ç½®è¿›åº¦
stopBackgroundMusic();

if (currentMode === 'pomodoro') {
 currentTime = selectedMinutes * 60;
} else {
 currentTime = 0;
}
updateTimerDisplay();

resetToSingleButton();
enableModeSwitch();

if (!isIgnoring) {
 showOCMessage(getInitialMessage(), 'initial', true);
}
}

 function resetToSingleButton() {
     document.getElementById('threeButtonLayout').classList.add('hidden');
     document.getElementById('singleButtonLayout').classList.remove('hidden');
     
     const startBtnHint = document.getElementById('startBtnHint');
     if (!isStatusSelected) {
         startBtnHint.classList.remove('hidden');
     } else {
         startBtnHint.classList.add('hidden');
     }
     
     document.getElementById('pauseBtn').innerHTML = `
         <svg class="w-8 h-8" fill="white" viewBox="0 0 24 24">
             <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
         </svg>
     `;
 }

 function startHeartbeatAnimation() {
     const leftPath = document.querySelector('.heartbeat-path-left');
     const rightPath = document.querySelector('.heartbeat-path-right');
     
     if (leftPath) leftPath.classList.remove('static');
     if (rightPath) rightPath.classList.remove('static');
 }

 function stopHeartbeatAnimation() {
     const leftPath = document.querySelector('.heartbeat-path-left');
     const rightPath = document.querySelector('.heartbeat-path-right');
     
     if (leftPath) leftPath.classList.add('static');
     if (rightPath) rightPath.classList.add('static');
 }

 function enableModeSwitch() {
     document.getElementById('pomodoroBtn').style.pointerEvents = 'auto';
     document.getElementById('timerBtn').style.pointerEvents = 'auto';
     document.getElementById('pomodoroBtn').style.opacity = '1';
     document.getElementById('timerBtn').style.opacity = '1';
 }

// éŸ³é¢‘ç®¡ç†å‡½æ•°
function initAudio() {
// é¢„åŠ è½½å®ŒæˆéŸ³æ•ˆ
completionAudio = new Audio(audioFiles.completion);
completionAudio.preload = 'auto';
completionAudio.volume = 0.7;

// é”™è¯¯å¤„ç†
completionAudio.addEventListener('error', function(e) {
 console.log('å®ŒæˆéŸ³æ•ˆåŠ è½½å¤±è´¥:', e);
});
}

function playBackgroundMusic(type) {
stopBackgroundMusic();

if (!isMusicEnabled || type === 'mute') return;

musicType = type; // è®°å½•å½“å‰éŸ³ä¹ç±»å‹
const audioUrl = type === 'music' ? audioFiles.music : audioFiles.rain;

try {
 currentBackgroundMusic = new Audio(audioUrl);
 currentBackgroundMusic.loop = true;
 currentBackgroundMusic.volume = 0.3;
 
 // è®¾ç½®æ’­æ”¾è¿›åº¦
 if (musicPausedTime > 0) {
     currentBackgroundMusic.currentTime = musicPausedTime;
 }
 
 // æ·»åŠ é”™è¯¯å¤„ç†
 currentBackgroundMusic.addEventListener('error', function(e) {
     console.log('èƒŒæ™¯éŸ³ä¹åŠ è½½å¤±è´¥:', e);
     currentBackgroundMusic = null;
 });
 
 // æ·»åŠ åŠ è½½å®Œæˆå¤„ç†
 currentBackgroundMusic.addEventListener('canplaythrough', function() {
     if (currentBackgroundMusic) {
         currentBackgroundMusic.play().catch(e => {
             console.log('éŸ³ä¹æ’­æ”¾å¤±è´¥ï¼Œå¯èƒ½éœ€è¦ç”¨æˆ·äº¤äº’:', e);
         });
     }
 });
 
} catch (error) {
 console.log('åˆ›å»ºéŸ³é¢‘å¯¹è±¡å¤±è´¥:', error);
}
}

function stopBackgroundMusic() {
if (currentBackgroundMusic) {
 currentBackgroundMusic.pause();
 currentBackgroundMusic.currentTime = 0;
 currentBackgroundMusic = null;
}
musicPausedTime = 0; // é‡ç½®è¿›åº¦
}

function pauseBackgroundMusic() {
if (currentBackgroundMusic) {
 musicPausedTime = currentBackgroundMusic.currentTime; // ä¿å­˜å½“å‰æ’­æ”¾è¿›åº¦
 currentBackgroundMusic.pause();
}
}

function resumeBackgroundMusic() {
if (musicType !== 'mute' && currentMusicMode > 0) {
 playBackgroundMusic(musicType);
}
}

function stopCompletionSound() {
if (completionAudio) {
 completionAudio.pause();
 completionAudio.currentTime = 0;
}
}



function stopBackgroundMusic() {
if (currentBackgroundMusic) {
 currentBackgroundMusic.pause();
 currentBackgroundMusic.currentTime = 0;
 currentBackgroundMusic = null;
}
}

function playCompletionSound() {
if (!isMusicEnabled || !completionAudio) return;

try {
 completionAudio.currentTime = 0;
 completionAudio.play().catch(e => {
     console.log('å®ŒæˆéŸ³æ•ˆæ’­æ”¾å¤±è´¥:', e);
 });
} catch (error) {
 console.log('æ’­æ”¾å®ŒæˆéŸ³æ•ˆæ—¶å‡ºé”™:', error);
}
}


function toggleMusic() {
currentMusicMode = (currentMusicMode + 1) % 3;
const musicBtn = document.getElementById('musicBtn');
const icon = musicIcons[currentMusicMode];

// æ›´æ–°æŒ‰é’®å›¾æ ‡
musicBtn.innerHTML = `<span style="font-size: 28px;">${icon}</span>`;

// æ ¹æ®æ¨¡å¼æ’­æ”¾ç›¸åº”éŸ³ä¹
switch(currentMusicMode) {
 case 0: // é™éŸ³
     stopBackgroundMusic();
     break;
 case 1: // éŸ³ä¹
     playBackgroundMusic('music');
     break;
 case 2: // é›¨å£°
     playBackgroundMusic('rain');
     break;
}
}

 // ç•ªèŒ„é’Ÿå®Œæˆç›¸å…³
 function showPomodoroComplete() {
        // è®°å½•ç•ªèŒ„é’Ÿå®Œæˆæ•°æ®
        const completedDuration = selectedMinutes * 60;
        recordPomodoro(completedDuration, currentTask.name, currentStatus.name);

     stopBackgroundMusic();
     playCompletionSound();
     const ocAvatar = document.querySelector('.oc-avatar');
     if (ocAvatar) {
         ocAvatar.classList.add('celebration');
         setTimeout(() => {
             ocAvatar.classList.remove('celebration');
         }, 1000);
     }
     
     const gift = getRandomGift();
     const completionMessage = getRandomOCMessage('completion');
     const senderOC = ocData[focusStartOCIndex] || ocData[currentOCIndex];
     
     addGift(gift, focusStartOCIndex);
     // æ›´æ–°æ•°æ®ä¸­å¿ƒé¡µé¢ï¼ˆå¦‚æœå½“å‰åœ¨æ•°æ®ä¸­å¿ƒé¡µé¢ï¼‰
updateDataCenterIfActive();
     
     createCelebrationParticles();
     
     showCompletionModal(completionMessage, senderOC.name, currentStatus.name, gift);
     
     currentTime = selectedMinutes * 60;
     updateTimerDisplay();
     if (!isIgnoring) {
         showOCMessage(getInitialMessage(), 'initial', true);
     }
 }

 function getRandomGift() {
     const senderOC = ocData[focusStartOCIndex] || ocData[currentOCIndex];

// ä¼˜å…ˆä½¿ç”¨çŠ¶æ€å¯¹åº”çš„ç¤¼ç‰©
if (currentStatus.name && statusGifts[currentStatus.name] && statusGifts[currentStatus.name].length > 0) {
 const statusGiftList = statusGifts[currentStatus.name];
 return statusGiftList[Math.floor(Math.random() * statusGiftList.length)];
}

// å…¶æ¬¡ä½¿ç”¨è‡ªå®šä¹‰ç¤¼ç‰©
if (senderOC.customGifts && senderOC.customGifts.trim()) {
 const customGifts = senderOC.customGifts.trim().split('\n').filter(gift => gift.trim());
 if (customGifts.length > 0) {
     return customGifts[Math.floor(Math.random() * customGifts.length)].trim();
 }
}

// æœ€åä½¿ç”¨é»˜è®¤ç¤¼ç‰©
const defaultGifts = [
 'ğŸ ä¸“å±å®šåˆ¶å¥–æ¯ï¼ä½ æ˜¯æœ€æ£’çš„ï¼',
 'â­ é—ªäº®æ˜Ÿæ˜Ÿå¾½ç« ï¼ç»§ç»­åŠ æ²¹ï¼',
 'ğŸ’ çè´µå®çŸ³ï¼ä½ çš„åŠªåŠ›å¾ˆçè´µï¼',
 'ğŸ† æˆå°±å‹‹ç« ï¼ä¸ºä½ çš„åšæŒå–å½©ï¼',
 'ğŸŒŸ å…‰èŠ’å››å°„ï¼ä½ é—ªé—ªå‘å…‰ï¼'
];

return defaultGifts[Math.floor(Math.random() * defaultGifts.length)];
}

 function createCelebrationParticles() {
     const particles = ['â­', 'ğŸ’', 'ğŸŒŸ', 'âœ¨', 'ğŸ’«', 'ğŸ”¸', 'ğŸ”¹'];
     
     for (let i = 0; i < 12; i++) {
         setTimeout(() => {
             const particle = document.createElement('div');
             particle.className = 'celebration-particle';
             particle.textContent = particles[Math.floor(Math.random() * particles.length)];
             particle.style.left = Math.random() * window.innerWidth + 'px';
             particle.style.animationDelay = Math.random() * 0.5 + 's';
             particle.style.animationDuration = (Math.random() * 2 + 3) + 's';
             document.body.appendChild(particle);
             
             setTimeout(() => {
                 if (particle.parentNode) {
                     particle.remove();
                 }
             }, 4500);
         }, i * 150);
     }
 }

 function showCompletionModal(completionMessage, ocName, statusName, gift) {
const modal = document.getElementById('completionModal');
const titleElement = document.getElementById('completionTitle');
const giftElement = document.getElementById('completionGift');

titleElement.textContent = `ğŸ‰ ${completionMessage}`;
// ä¿®æ”¹ï¼šæ”¹å˜æ’ç‰ˆæ ¼å¼ï¼Œæ·»åŠ æ¢è¡Œ
giftElement.innerHTML = `${ocName}${statusName}ç»“æŸå•¦ï¼Œç»™ä½ å¸¦å›äº†<br>${gift}`;

modal.classList.add('show');
}

 function closeCompletionModal() {
     document.getElementById('completionModal').classList.remove('show');
     stopCompletionSound();
 }




 // é£˜è½æ•ˆæœ
 function createFallingElements() {
     const elements = ['ğŸŒ¸'];
     
     function createSingleElement() {
         const element = document.createElement('div');
         element.className = 'falling-petals';
         element.textContent = elements[Math.floor(Math.random() * elements.length)];
         element.style.left = Math.random() * window.innerWidth + 'px';
         element.style.animationDuration = (Math.random() * 3 + 4) + 's';
         element.style.animationDelay = Math.random() * 2 + 's';
         
         document.body.appendChild(element);
         
         setTimeout(() => {
             if (element.parentNode) {
                 element.remove();
             }
         }, 9000);
     }
     
     for (let i = 0; i < 3; i++) {
         setTimeout(createSingleElement, i * 1000);
     }
     
     setInterval(createSingleElement, 2000);
 }

 // åˆå§‹åŒ–å’Œäº‹ä»¶ç›‘å¬
 function loadStoredData() {
     const storedOCData = localStorage.getItem('ocData');
     if (storedOCData) {
         try {
             const loadedData = JSON.parse(storedOCData);
             ocData = loadedData.map(oc => ({
                 ...oc,
                 customGifts: oc.customGifts || '',
                 encourageStyles: oc.encourageStyles || [oc.personality || 'gentle'],
                 reminderStyles: oc.reminderStyles || [oc.reminderStyle || 'guardian']
             }));
         } catch (e) {
             console.log('Failed to parse stored OC data');
         }
     }
     
     const storedOCIndex = localStorage.getItem('currentOCIndex');
     if (storedOCIndex && parseInt(storedOCIndex) < ocData.length) {
         currentOCIndex = parseInt(storedOCIndex);
     }
     
     updateCurrentOC(currentOCIndex);
     loadTasks();
     loadDailyStats();
     loadCustomStyles();
     loadStatusGiftsFromStorage();
     loadCustomStatusesFromStorage(); 
 }

 function initPageAnimation() {
     const cards = document.querySelectorAll('.glass-card');
     cards.forEach((card, index) => {
         card.style.opacity = '0';
         card.style.transform = 'translateY(20px)';
         setTimeout(() => {
             card.style.transition = 'all 0.6s ease';
             card.style.opacity = '1';
             card.style.transform = 'translateY(0)';
         }, index * 100 + 200);
     });
 }

 function updateCurrentDate() {
     const now = new Date();
     const weekdays = ['æ˜ŸæœŸæ—¥', 'æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­'];
     const dateStr = `${now.getFullYear()}å¹´${(now.getMonth() + 1).toString().padStart(2, '0')}æœˆ${now.getDate().toString().padStart(2, '0')}æ—¥ ${weekdays[now.getDay()]}`;
     document.getElementById('currentDate').textContent = dateStr;
 }

 function initEventListeners() {
     document.getElementById('pomodoroBtn').addEventListener('click', () => switchMode('pomodoro'));
     document.getElementById('timerBtn').addEventListener('click', () => switchMode('timer'));
     
     document.addEventListener('click', function(e) {
         const statusSelector = document.getElementById('statusSelector');
         const statusButton = document.getElementById('statusButton');
         const timeSelector = document.getElementById('timeSelector');
         const timerDisplay = document.getElementById('timerDisplay');
         const taskSelector = document.getElementById('taskSelector');
         const taskContainer = document.querySelector('[onclick="showTaskSelector()"]');
         const giftModal = document.getElementById('giftModal');
         const completedTasksModal = document.getElementById('completedTasksModal');
         const completionModal = document.getElementById('completionModal');
         const styleEditorModal = document.getElementById('styleEditorModal');
         
         if (statusSelector && !statusSelector.contains(e.target) && 
             e.target !== statusButton && !statusButton.contains(e.target)) {
             statusSelector.classList.remove('show');
             hideCustomStatusInput();
         }
         
         if (timeSelector && !timeSelector.contains(e.target) && 
             e.target !== timerDisplay) {
             timeSelector.classList.remove('show');
         }
         
         if (taskSelector && !taskSelector.contains(e.target) && 
             taskContainer && !taskContainer.contains(e.target)) {
             taskSelector.classList.remove('show');
         }
         
         if (giftModal && giftModal.classList.contains('show') && e.target === giftModal) {
             closeGiftModal();
         }
         
         if (completedTasksModal && completedTasksModal.classList.contains('show') && e.target === completedTasksModal) {
             closeCompletedTasksModal();
         }
         
         if (completionModal && completionModal.classList.contains('show') && e.target === completionModal) {
             closeCompletionModal();
         }
         
         if (styleEditorModal && styleEditorModal.classList.contains('show') && e.target === styleEditorModal) {
             closeStyleEditor();
             const statusGiftEditorModal = document.getElementById('statusGiftEditorModal');
if (statusGiftEditorModal && statusGiftEditorModal.classList.contains('show') && e.target === statusGiftEditorModal) {
closeStatusGiftEditor();
}
         }
     });
 }

 // é¡µé¢åˆå§‹åŒ–
 document.addEventListener('DOMContentLoaded', function() {
     loadStoredData();
     loadDetailedStats(); // æ–°å¢ï¼šåŠ è½½è¯¦ç»†ç»Ÿè®¡æ•°æ®
     updateCurrentDate();
     updateTimerDisplay();
     initAudio();
     initAIEncouragement(); 
     
     const musicBtn = document.getElementById('musicBtn');
     if (musicBtn) {
         musicBtn.innerHTML = `
             <svg class="w-7 h-7" fill="currentColor" viewBox="0 0 24 24">
                 <text x="12" y="16" text-anchor="middle" font-size="16">ğŸ”‡</text>
             </svg>
         `;
     }
     
     initEventListeners();
     createFallingElements();
     setTimeout(initPageAnimation, 100);
     renderTasks();
 });




// åˆå§‹åŒ–AIé¼“åŠ±è¯­åŠŸèƒ½
function initAIEncouragement() {
    // å­—æ•°ç»Ÿè®¡
    const charDescInput = document.getElementById('characterDescription');
    if (charDescInput) {
        charDescInput.addEventListener('input', function(e) {
            const text = e.target.value;
            const length = text.length;
            const counter = document.getElementById('charCounter');
            
            if (counter) {
                counter.textContent = `${length}/500`;
                
                if (length > 450) {
                    counter.className = 'char-counter error';
                } else if (length > 400) {
                    counter.className = 'char-counter warning';
                } else {
                    counter.className = 'char-counter';
                }
            }
        });
    }
    
    // åŠ è½½å†å²è®°å½•
    renderAIPromptHistory();
}

// ç”ŸæˆAIé¼“åŠ±è¯­
function generateAIEncouragements() {
    const description = document.getElementById('characterDescription').value.trim();
    const quantity = parseInt(document.getElementById('quantitySelect').value);
    
    if (!description) {
        alert('è¯·å…ˆè¾“å…¥è§’è‰²äººè®¾æè¿°');
        return;
    }
    
    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    const btn = document.getElementById('generateBtn');
    btn.classList.add('loading');
    btn.disabled = true;
    btn.innerHTML = `
        <div class="loading-spinner"></div>
        ç”Ÿæˆä¸­...
    `;
    
    // ä¿å­˜åˆ°å†å²è®°å½•
    saveAIPromptToHistory(description);
}   




// æ¸²æŸ“AIç”Ÿæˆç»“æœ
function renderAIResults() {
    const container = document.getElementById('generatedResults');
    if (!container) return;
    
    if (aiGeneratedResults.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">âœ¨</div>
                <p>è¾“å…¥è§’è‰²äººè®¾æè¿°ï¼Œç‚¹å‡»"ç”Ÿæˆé¼“åŠ±è¯­"å¼€å§‹åˆ›é€ ä¸“å±äºä½ çš„OCè¯­è¨€</p>
            </div>
        `;
        return;
    }
    
    container.innerHTML = aiGeneratedResults.map(result => `
        <div class="result-item" data-id="${result.id}">
            <div class="result-text" ${result.isEditing ? 'contenteditable="true"' : ''}>${result.text}</div>
            <div class="result-actions">
                <button class="result-btn edit-btn" onclick="toggleAIEdit(${result.id})">
                    ${result.isEditing ? 'ä¿å­˜' : 'ç¼–è¾‘'}
                </button>
                <button class="result-btn adopt-btn" onclick="adoptAIResult(${result.id})">é‡‡ç”¨</button>
                <button class="result-btn regenerate-btn" onclick="regenerateAIOne(${result.id})">é‡æ–°ç”Ÿæˆ</button>
                <button class="result-btn delete-btn" onclick="deleteAIResult(${result.id})">åˆ é™¤</button>
            </div>
        </div>
    `).join('');
}

// åˆ‡æ¢AIç»“æœç¼–è¾‘æ¨¡å¼
function toggleAIEdit(id) {
    const result = aiGeneratedResults.find(r => r.id === id);
    if (!result) return;
    
    if (result.isEditing) {
        // ä¿å­˜ç¼–è¾‘
        const element = document.querySelector(`[data-id="${id}"] .result-text`);
        result.text = element.textContent.trim();
        result.isEditing = false;
    } else {
        // è¿›å…¥ç¼–è¾‘æ¨¡å¼
        result.isEditing = true;
    }
    
    renderAIResults();
}

// é‡‡ç”¨AIç”Ÿæˆçš„ç»“æœ
function adoptAIResult(id) {
    const result = aiGeneratedResults.find(r => r.id === id);
    if (!result) return;
    
    // å°†é¼“åŠ±è¯­æ·»åŠ åˆ°å½“å‰ç¼–è¾‘çš„OCçš„è‡ªå®šä¹‰é¼“åŠ±è¯­é£æ ¼ä¸­
    const ocIndex = editingOCIndex >= 0 ? editingOCIndex : currentOCIndex;
    const currentOC = ocData[ocIndex];
    
    // åˆ›å»ºè‡ªå®šä¹‰AIé£æ ¼ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
    const aiStyleId = `custom-ai-${ocIndex}`;
    if (!customStyles.encourage[aiStyleId]) {
        customStyles.encourage[aiStyleId] = [];
        if (!customStyles.metadata) {
            customStyles.metadata = {};
        }
        customStyles.metadata[aiStyleId] = {
            title: 'AIç”Ÿæˆ',
            type: 'encourage',
            desc: 'AIåŸºäºäººè®¾ç”Ÿæˆçš„é¼“åŠ±è¯­'
        };
    }
    
    // æ·»åŠ é¼“åŠ±è¯­
    customStyles.encourage[aiStyleId].push(result.text);
    
    // ç¡®ä¿OCé€‰æ‹©äº†è¿™ä¸ªé£æ ¼
    if (!currentOC.encourageStyles.includes(aiStyleId)) {
        currentOC.encourageStyles.push(aiStyleId);
    }
    
    // ä¿å­˜
    saveCustomStyles();
    localStorage.setItem('ocData', JSON.stringify(ocData));
    
    alert(`å·²é‡‡ç”¨é¼“åŠ±è¯­ï¼š${result.text.substring(0, 30)}...`);
    
    // é‡æ–°æ¸²æŸ“é£æ ¼é€‰æ‹©åŒºåŸŸ
    renderCustomStylesInGrid('encourage');
    selectStyleOptions('encourageStyleGrid', currentOC.encourageStyles);
}

// é‡æ–°ç”Ÿæˆå•ä¸ªAIç»“æœ
function regenerateAIOne(id) {
    const currentOC = ocData[editingOCIndex >= 0 ? editingOCIndex : currentOCIndex];
    const userTitle = currentOC.userTitle || 'å¤§å°å§';
    
    const mockResults = [
        `${userTitle}ï¼Œä½ çš„ä¸“æ³¨è®©æˆ‘æƒ³èµ·äº†èˆå°ä¸Šæœ€é—ªè€€çš„æ—¶åˆ»ï½`,
        `åŠ æ²¹å“¦ï¼æˆ‘ä¼šç”¨æœ€æ¸©æŸ”çš„æ­Œå£°ä¸ºä½ æ‰“æ°”çš„ï¼`,
        `çœ‹ç€ä½ åŠªåŠ›çš„æ ·å­ï¼Œæˆ‘çš„å¿ƒéƒ½è¢«æ¸©æš–äº†å‘¢ï½`
    ];
    
    const result = aiGeneratedResults.find(r => r.id === id);
    if (result) {
        result.text = mockResults[Math.floor(Math.random() * mockResults.length)];
        renderAIResults();
    }
}

// åˆ é™¤AIç»“æœ
function deleteAIResult(id) {
    aiGeneratedResults = aiGeneratedResults.filter(r => r.id !== id);
    renderAIResults();
}

// ä¿å­˜AI Promptåˆ°å†å²
function saveAIPromptToHistory(description) {
    const existing = aiPromptHistory.find(item => item.text === description);
    if (existing) {
        existing.lastUsed = new Date().toISOString();
    } else {
        aiPromptHistory.unshift({
            id: Date.now(),
            text: description,
            createdAt: new Date().toISOString(),
            lastUsed: new Date().toISOString()
        });
    }
    
    // é™åˆ¶å†å²è®°å½•æ•°é‡
    if (aiPromptHistory.length > 10) {
        aiPromptHistory = aiPromptHistory.slice(0, 10);
    }
    
    localStorage.setItem('aiPromptHistory', JSON.stringify(aiPromptHistory));
    renderAIPromptHistory();
}

// æ¸²æŸ“AI Promptå†å²
function renderAIPromptHistory() {
    const container = document.getElementById('promptHistory');
    if (!container) return;
    
    if (aiPromptHistory.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">ğŸ“š</div>
                <p>æš‚æ— å†å²äººè®¾è®°å½•</p>
            </div>
        `;
        return;
    }
    
    container.innerHTML = aiPromptHistory.map(item => `
        <div class="history-item" onclick="loadAIPrompt('${item.id}')">
            <div class="history-text">${item.text}</div>
            <div class="history-date">${new Date(item.lastUsed).toLocaleDateString()}</div>
            <button class="history-delete" onclick="event.stopPropagation(); deleteAIPrompt('${item.id}')">
                <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                </svg>
            </button>
        </div>
    `).join('');
}

// åŠ è½½AIå†å²prompt
function loadAIPrompt(id) {
    const prompt = aiPromptHistory.find(p => p.id == id);
    if (prompt) {
        const input = document.getElementById('characterDescription');
        if (input) {
            input.value = prompt.text;
            input.dispatchEvent(new Event('input'));
        }
    }
}

// åˆ é™¤AIå†å²prompt
function deleteAIPrompt(id) {
    aiPromptHistory = aiPromptHistory.filter(p => p.id != id);
    localStorage.setItem('aiPromptHistory', JSON.stringify(aiPromptHistory));
    renderAIPromptHistory();
}

// åˆ‡æ¢AIåŒºåŸŸæ˜¾ç¤º
function toggleAISection(sectionId) {
    const section = document.getElementById(sectionId);
    if (!section) return;
    
    const isVisible = section.style.display !== 'none';
    
    if (isVisible) {
        section.style.display = 'none';
    } else {
        section.style.display = 'block';
    }
    
    // åˆ‡æ¢å›¾æ ‡
    const toggleBtn = event.currentTarget;
    const icon = toggleBtn.querySelector('.collapse-icon');
    if (icon) {
        icon.classList.toggle('collapsed', !isVisible);
    }
}


// åˆå§‹åŒ–AIé¼“åŠ±è¯­åŠŸèƒ½
function initAIEncouragement() {
    // å­—æ•°ç»Ÿè®¡
    const charDescInput = document.getElementById('characterDescription');
    if (charDescInput) {
        charDescInput.addEventListener('input', function(e) {
            const text = e.target.value;
            const length = text.length;
            const counter = document.getElementById('charCounter');
            
            if (counter) {
                counter.textContent = `${length}/500`;
                
                if (length > 450) {
                    counter.className = 'char-counter error';
                } else if (length > 400) {
                    counter.className = 'char-counter warning';
                } else {
                    counter.className = 'char-counter';
                }
            }
        });
    }
    
    // åŠ è½½å†å²è®°å½•
    renderAIPromptHistory();
}

// ç”ŸæˆAIé¼“åŠ±è¯­ï¼ˆè°ƒç”¨çœŸå®APIï¼‰
async function generateAIEncouragements() {
    const description = document.getElementById('characterDescription').value.trim();
    const quantity = parseInt(document.getElementById('quantitySelect').value);
    const currentOC = ocData[editingOCIndex >= 0 ? editingOCIndex : currentOCIndex];
    const userTitle = currentOC.userTitle || 'å¤§å°å§';
    
    if (!description) {
        alert('è¯·å…ˆè¾“å…¥è§’è‰²äººè®¾æè¿°');
        return;
    }
    
    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    const btn = document.getElementById('generateBtn');
    btn.classList.add('loading');
    btn.disabled = true;
    btn.innerHTML = `
        <div class="loading-spinner"></div>
        ç”Ÿæˆä¸­...
    `;
    
    // ä¿å­˜åˆ°å†å²è®°å½•
    saveAIPromptToHistory(description);
    
    // è°ƒç”¨API
    const response = await generateEncouragements(description, quantity, userTitle);
    
    if (response.success) {
        // å¤„ç†æˆåŠŸç»“æœ
        aiGeneratedResults = response.data.results.map((text, index) => ({
            id: Date.now() + index,
            text: text,
            isEditing: false
        }));
        renderAIResults();
    } else {
        // å¤„ç†é”™è¯¯
        const errorMessage = handleAPIError(response.error);
        alert(errorMessage);
    }
    
    // æ¢å¤æŒ‰é’®çŠ¶æ€
    btn.classList.remove('loading');
    btn.disabled = false;
    btn.innerHTML = `
        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
        </svg>
        ç”Ÿæˆé¼“åŠ±è¯­
    `;
}




// æ¸²æŸ“AIç”Ÿæˆç»“æœ
function renderAIResults() {
    const container = document.getElementById('generatedResults');
    if (!container) return;
    
    if (aiGeneratedResults.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">âœ¨</div>
                <p>è¾“å…¥è§’è‰²äººè®¾æè¿°ï¼Œç‚¹å‡»"ç”Ÿæˆé¼“åŠ±è¯­"å¼€å§‹åˆ›é€ ä¸“å±äºä½ çš„OCè¯­è¨€</p>
            </div>
        `;
        return;
    }
    
    container.innerHTML = aiGeneratedResults.map(result => `
        <div class="result-item" data-id="${result.id}">
            <div class="result-text" ${result.isEditing ? 'contenteditable="true"' : ''}>${result.text}</div>
            <div class="result-actions">
                <button class="result-btn edit-btn" onclick="toggleAIEdit(${result.id})">
                    ${result.isEditing ? 'ä¿å­˜' : 'ç¼–è¾‘'}
                </button>
                <button class="result-btn adopt-btn" onclick="adoptAIResult(${result.id})">é‡‡ç”¨</button>
                <button class="result-btn regenerate-btn" onclick="regenerateAIOne(${result.id})">é‡æ–°ç”Ÿæˆ</button>
                <button class="result-btn delete-btn" onclick="deleteAIResult(${result.id})">åˆ é™¤</button>
            </div>
        </div>
    `).join('');
}

// åˆ‡æ¢AIç»“æœç¼–è¾‘æ¨¡å¼
function toggleAIEdit(id) {
    const result = aiGeneratedResults.find(r => r.id === id);
    if (!result) return;
    
    if (result.isEditing) {
        // ä¿å­˜ç¼–è¾‘
        const element = document.querySelector(`[data-id="${id}"] .result-text`);
        result.text = element.textContent.trim();
        result.isEditing = false;
    } else {
        // è¿›å…¥ç¼–è¾‘æ¨¡å¼
        result.isEditing = true;
    }
    
    renderAIResults();
}

// é‡‡ç”¨AIç”Ÿæˆçš„ç»“æœ
function adoptAIResult(id) {
    const result = aiGeneratedResults.find(r => r.id === id);
    if (!result) return;
    
    // å°†é¼“åŠ±è¯­æ·»åŠ åˆ°å½“å‰ç¼–è¾‘çš„OCçš„è‡ªå®šä¹‰é¼“åŠ±è¯­é£æ ¼ä¸­
    const ocIndex = editingOCIndex >= 0 ? editingOCIndex : currentOCIndex;
    const currentOC = ocData[ocIndex];
    
    // åˆ›å»ºè‡ªå®šä¹‰AIé£æ ¼ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
    const aiStyleId = `custom-ai-${ocIndex}`;
    if (!customStyles.encourage[aiStyleId]) {
        customStyles.encourage[aiStyleId] = [];
        if (!customStyles.metadata) {
            customStyles.metadata = {};
        }
        customStyles.metadata[aiStyleId] = {
            title: 'AIç”Ÿæˆ',
            type: 'encourage',
            desc: 'AIåŸºäºäººè®¾ç”Ÿæˆçš„é¼“åŠ±è¯­'
        };
    }
    
    // æ·»åŠ é¼“åŠ±è¯­
    customStyles.encourage[aiStyleId].push(result.text);
    
    // ç¡®ä¿OCé€‰æ‹©äº†è¿™ä¸ªé£æ ¼
    if (!currentOC.encourageStyles.includes(aiStyleId)) {
        currentOC.encourageStyles.push(aiStyleId);
    }
    
    // ä¿å­˜
    saveCustomStyles();
    localStorage.setItem('ocData', JSON.stringify(ocData));
    
    alert(`å·²é‡‡ç”¨é¼“åŠ±è¯­ï¼š${result.text.substring(0, 30)}...`);
    
    // é‡æ–°æ¸²æŸ“é£æ ¼é€‰æ‹©åŒºåŸŸ
    renderCustomStylesInGrid('encourage');
    selectStyleOptions('encourageStyleGrid', currentOC.encourageStyles);
}

// é‡æ–°ç”Ÿæˆå•ä¸ªAIç»“æœ
async function regenerateAIOne(id) {
    const description = document.getElementById('characterDescription').value.trim();
    const currentOC = ocData[editingOCIndex >= 0 ? editingOCIndex : currentOCIndex];
    const userTitle = currentOC.userTitle || 'å¤§å°å§';
    
    if (!description) {
        alert('è¯·è¾“å…¥è§’è‰²äººè®¾æè¿°');
        return;
    }
    
    const response = await regenerateSingleEncouragement(description, userTitle);
    
    if (response.success) {
        const result = aiGeneratedResults.find(r => r.id === id);
        if (result) {
            result.text = response.data;
            renderAIResults();
        }
    } else {
        const errorMessage = handleAPIError(response.error);
        alert(errorMessage);
    }
}

// åˆ é™¤AIç»“æœ
function deleteAIResult(id) {
    aiGeneratedResults = aiGeneratedResults.filter(r => r.id !== id);
    renderAIResults();
}

// ä¿å­˜AI Promptåˆ°å†å²
function saveAIPromptToHistory(description) {
    const existing = aiPromptHistory.find(item => item.text === description);
    if (existing) {
        existing.lastUsed = new Date().toISOString();
    } else {
        aiPromptHistory.unshift({
            id: Date.now(),
            text: description,
            createdAt: new Date().toISOString(),
            lastUsed: new Date().toISOString()
        });
    }
    
    // é™åˆ¶å†å²è®°å½•æ•°é‡
    if (aiPromptHistory.length > 10) {
        aiPromptHistory = aiPromptHistory.slice(0, 10);
    }
    
    localStorage.setItem('aiPromptHistory', JSON.stringify(aiPromptHistory));
    renderAIPromptHistory();
}



// åŠ è½½AIå†å²prompt
function loadAIPrompt(id) {
    const prompt = aiPromptHistory.find(p => p.id == id);
    if (prompt) {
        const input = document.getElementById('characterDescription');
        if (input) {
            input.value = prompt.text;
            input.dispatchEvent(new Event('input'));
        }
    }
}

// åˆ é™¤AIå†å²prompt
function deleteAIPrompt(id) {
    aiPromptHistory = aiPromptHistory.filter(p => p.id != id);
    localStorage.setItem('aiPromptHistory', JSON.stringify(aiPromptHistory));
    renderAIPromptHistory();
}

// åˆ‡æ¢AIåŒºåŸŸæ˜¾ç¤º
function toggleAISection(sectionId) {
    const section = document.getElementById(sectionId);
    if (!section) return;
    
    const isVisible = section.style.display !== 'none';
    
    if (isVisible) {
        section.style.display = 'none';
    } else {
        section.style.display = 'block';
    }
    
    // åˆ‡æ¢å›¾æ ‡
    const toggleBtn = event.currentTarget;
    const icon = toggleBtn.querySelector('.collapse-icon');
    if (icon) {
        icon.classList.toggle('collapsed', !isVisible);
    }
}
 // APIé…ç½®ç›¸å…³å‡½æ•°
function toggleAPIConfig() {
    const panel = document.getElementById('apiConfigPanel');
    const toggleText = document.getElementById('apiConfigToggleText');
    
    if (panel.classList.contains('hidden')) {
        panel.classList.remove('hidden');
        toggleText.textContent = 'æ”¶èµ·è®¾ç½® â–²';
        
        // åŠ è½½å·²ä¿å­˜çš„é…ç½®
        loadSavedAPIConfig();
    } else {
        panel.classList.add('hidden');
        toggleText.textContent = 'å±•å¼€è®¾ç½® â–¼';
    }
}
// APIé…ç½®æ˜¾ç¤º/éšè—åŠŸèƒ½
function toggleAPIConfig() {
    const panel = document.getElementById('apiConfigPanel');
    const toggleText = document.getElementById('apiConfigToggleText');
    
    if (panel.classList.contains('hidden')) {
        panel.classList.remove('hidden');
        toggleText.textContent = 'æ”¶èµ·è®¾ç½® â–²';
        
        // åŠ è½½å·²ä¿å­˜çš„é…ç½®
        loadSavedAPIConfig();
    } else {
        panel.classList.add('hidden');
        toggleText.textContent = 'å±•å¼€è®¾ç½® â–¼';
    }
}

// APIå¯†é’¥å¯è§æ€§åˆ‡æ¢
function toggleAPIKeyVisibility() {
    const input = document.getElementById('apiKeyInput');
    const icon = document.getElementById('apiKeyVisibilityIcon');
    
    if (input.type === 'password') {
        input.type = 'text';
        icon.innerHTML = `
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path>
        `;
    } else {
        input.type = 'password';
        icon.innerHTML = `
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
        `;
    }
}

// AIæœåŠ¡åˆ‡æ¢å¤„ç†
function onAIServiceChange() {
    const service = document.getElementById('aiServiceSelect').value;
    const urlInput = document.getElementById('apiUrlInput');
    const modelInput = document.getElementById('modelInput');
    
    // é¢„è®¾çš„API URL
    const presetUrls = {
        'openai': 'https://api.openai.com/v1/chat/completions',
        'gemini': 'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent',
        'deepseek': 'https://api.deepseek.com/v1/chat/completions',
        'doubao': 'https://ark.cn-beijing.volces.com/api/v3/chat/completions',
        'custom': ''
    };
    
    // é¢„è®¾çš„æ¨¡å‹
    const presetModels = {
        'openai': 'gpt-3.5-turbo',
        'gemini': 'gemini-pro',
        'deepseek': 'deepseek-chat',
        'doubao': 'ep-20241129163851-8qmzh',
        'custom': ''
    };
    
    if (service === 'custom') {
        urlInput.value = '';
        urlInput.placeholder = 'è¯·è¾“å…¥å®Œæ•´çš„API URL';
        modelInput.value = '';
    } else {
        urlInput.value = presetUrls[service] || '';
        modelInput.value = presetModels[service] || '';
    }
}


function toggleAPIKeyVisibility() {
    const input = document.getElementById('apiKeyInput');
    const icon = document.getElementById('apiKeyVisibilityIcon');
    
    if (input.type === 'password') {
        input.type = 'text';
        icon.innerHTML = `
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path>
        `;
    } else {
        input.type = 'password';
        icon.innerHTML = `
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
        `;
    }
}

function loadSavedAPIConfig() {
    const savedService = localStorage.getItem('aiService') || 'openai';
    const savedKey = localStorage.getItem('apiKey') || '';
    
    document.getElementById('aiServiceSelect').value = savedService;
    document.getElementById('apiKeyInput').value = savedKey;
}

function saveAPIConfig() {
    const service = document.getElementById('aiServiceSelect').value;
    const apiKey = document.getElementById('apiKeyInput').value.trim();
    
    if (!apiKey) {
        alert('è¯·è¾“å…¥APIå¯†é’¥');
        return;
    }
    
    // ä¿å­˜åˆ°localStorageå’Œå†…å­˜
    saveAPIConfig(apiKey, service);
    
    // æ˜¾ç¤ºæˆåŠŸæç¤º
    const btn = event.currentTarget;
    const originalText = btn.textContent;
    btn.textContent = 'âœ“ é…ç½®å·²ä¿å­˜';
    btn.classList.add('bg-green-500');
    
    setTimeout(() => {
        btn.textContent = originalText;
        btn.classList.remove('bg-green-500');
    }, 2000);
    
    // è‡ªåŠ¨æ”¶èµ·é…ç½®é¢æ¿
    setTimeout(() => {
        document.getElementById('apiConfigPanel').classList.add('hidden');
        document.getElementById('apiConfigToggleText').textContent = 'å±•å¼€è®¾ç½® â–¼';
    }, 2000);
}

// APIé…ç½®ä¿å­˜å‡½æ•°
function saveAPIConfiguration() {
    const service = document.getElementById('aiServiceSelect').value;
    const apiKey = document.getElementById('apiKeyInput').value.trim();
    
    if (!apiKey) {
        alert('è¯·è¾“å…¥APIå¯†é’¥');
        return;
    }
    
    // ä¿å­˜åˆ°localStorageå’Œå†…å­˜
    saveAPIConfig(apiKey, service);
    
    // æ˜¾ç¤ºæˆåŠŸæç¤º
    const btn = event.currentTarget;
    const originalText = btn.textContent;
    btn.textContent = 'âœ” é…ç½®å·²ä¿å­˜';
    btn.classList.add('bg-green-500');
    
    setTimeout(() => {
        btn.textContent = originalText;
        btn.classList.remove('bg-green-500');
    }, 2000);
    
    // è‡ªåŠ¨æ”¶èµ·é…ç½®é¢æ¿
    setTimeout(() => {
        document.getElementById('apiConfigPanel').classList.add('hidden');
        document.getElementById('apiConfigToggleText').textContent = 'å±•å¼€è®¾ç½® â–¼';
    }, 2000);
}

// APIæœåŠ¡åˆ‡æ¢å¤„ç†
function onAIServiceChange() {
    const service = document.getElementById('aiServiceSelect').value;
    const urlContainer = document.getElementById('apiUrlContainer');
    const urlInput = document.getElementById('apiUrlInput');
    const urlHint = document.getElementById('apiUrlHint');
    const modelContainer = document.getElementById('modelContainer');
    const modelInput = document.getElementById('modelInput');
    
    // é¢„è®¾çš„API URL
    const presetUrls = {
        'openai': 'https://api.openai.com/v1/chat/completions',
        'gemini': 'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent',
        'deepseek': 'https://api.deepseek.com/v1/chat/completions',
        'doubao': 'https://ark.cn-beijing.volces.com/api/v3/chat/completions',
        'custom': ''
    };
    
    // é¢„è®¾çš„æ¨¡å‹
    const presetModels = {
        'openai': 'gpt-3.5-turbo',
        'gemini': 'gemini-pro',
        'deepseek': 'deepseek-chat',
        'doubao': 'ep-20241129163851-8qmzh',
        'custom': ''
    };
    
    if (service === 'custom') {
        urlInput.value = '';
        urlInput.placeholder = 'è¯·è¾“å…¥å®Œæ•´çš„API URL';
        urlHint.textContent = 'è¾“å…¥ä½ çš„è‡ªå®šä¹‰APIç«¯ç‚¹åœ°å€';
        modelInput.value = '';
    } else {
        urlInput.value = presetUrls[service] || '';
        urlHint.textContent = `ä½¿ç”¨${service}çš„é»˜è®¤APIåœ°å€`;
        modelInput.value = presetModels[service] || '';
    }
}


// åŠ è½½ä¿å­˜çš„APIé…ç½®ï¼ˆè¦†ç›–åŸæœ‰å‡½æ•°ï¼‰
function loadSavedAPIConfig() {
    const savedService = localStorage.getItem('aiService') || 'openai';
    const savedKey = localStorage.getItem('apiKey') || '';
    const savedUrl = localStorage.getItem('apiUrl') || '';
    const savedModel = localStorage.getItem('apiModel') || 'gpt-3.5-turbo';
    
    document.getElementById('aiServiceSelect').value = savedService;
    document.getElementById('apiKeyInput').value = savedKey;
    document.getElementById('apiUrlInput').value = savedUrl;
    document.getElementById('modelInput').value = savedModel;
    
    // è§¦å‘æœåŠ¡åˆ‡æ¢ä»¥æ›´æ–°UI
    onAIServiceChange();
}

// ä¿å­˜APIé…ç½®ï¼ˆè¦†ç›–åŸæœ‰å‡½æ•°ï¼‰
function saveAPIConfiguration() {
    const service = document.getElementById('aiServiceSelect').value;
    const apiKey = document.getElementById('apiKeyInput').value.trim();
    const apiUrl = document.getElementById('apiUrlInput').value.trim();
    const model = document.getElementById('modelInput').value.trim();
    
    if (!apiKey) {
        alert('è¯·è¾“å…¥APIå¯†é’¥');
        return;
    }
    
    if (!apiUrl) {
        alert('è¯·è¾“å…¥API URL');
        return;
    }
    
    if (!model) {
        alert('è¯·è¾“å…¥æ¨¡å‹åç§°');
        return;
    }
    
    // ä¿å­˜åˆ°localStorageå’Œå†…å­˜
    saveAPIConfig(apiKey, service, apiUrl, model);
    
    // æ˜¾ç¤ºæˆåŠŸæç¤º
    const btn = event.currentTarget;
    const originalText = btn.textContent;
    btn.textContent = 'âœ” é…ç½®å·²ä¿å­˜';
    btn.classList.add('bg-green-500');
    
    setTimeout(() => {
        btn.textContent = originalText;
        btn.classList.remove('bg-green-500');
    }, 2000);
    
    // è‡ªåŠ¨æ”¶èµ·é…ç½®é¢æ¿
    setTimeout(() => {
        document.getElementById('apiConfigPanel').classList.add('hidden');
        document.getElementById('apiConfigToggleText').textContent = 'å±•å¼€è®¾ç½® â–¼';
    }, 2000);
}


 window.addEventListener('load', function() {
     initPageAnimation();
 }); 

